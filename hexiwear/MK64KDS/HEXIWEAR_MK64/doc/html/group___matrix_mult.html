<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Matrix Multiplication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___matrix_mult.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix Multiplication<div class="ingroups"><a class="el" href="group__group_matrix.html">Matrix Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga917bf0270310c1d3f0eda1fc7c0026a0"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___matrix_mult.html#ga917bf0270310c1d3f0eda1fc7c0026a0">arm_mat_mult_f32</a> (const <a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *pSrcA, const <a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *pSrcB, <a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *pDst)</td></tr>
<tr class="memdesc:ga917bf0270310c1d3f0eda1fc7c0026a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating-point matrix multiplication.  <a href="#ga917bf0270310c1d3f0eda1fc7c0026a0">More...</a><br /></td></tr>
<tr class="separator:ga917bf0270310c1d3f0eda1fc7c0026a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f37d93a5bfef0c5000dc5e0a411f93"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___matrix_mult.html#ga08f37d93a5bfef0c5000dc5e0a411f93">arm_mat_mult_fast_q15</a> (const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pSrcA, const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pSrcB, <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pDst, q15_t *pState)</td></tr>
<tr class="memdesc:ga08f37d93a5bfef0c5000dc5e0a411f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4.  <a href="#ga08f37d93a5bfef0c5000dc5e0a411f93">More...</a><br /></td></tr>
<tr class="separator:ga08f37d93a5bfef0c5000dc5e0a411f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2785e8c1b785348b0c439b56aaf585a3"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___matrix_mult.html#ga2785e8c1b785348b0c439b56aaf585a3">arm_mat_mult_fast_q31</a> (const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pSrcA, const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pSrcB, <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pDst)</td></tr>
<tr class="memdesc:ga2785e8c1b785348b0c439b56aaf585a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4.  <a href="#ga2785e8c1b785348b0c439b56aaf585a3">More...</a><br /></td></tr>
<tr class="separator:ga2785e8c1b785348b0c439b56aaf585a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3657b99a9667945373e520dbac0f4516"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___matrix_mult.html#ga3657b99a9667945373e520dbac0f4516">arm_mat_mult_q15</a> (const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pSrcA, const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pSrcB, <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *pDst, q15_t *pState CMSIS_UNUSED)</td></tr>
<tr class="memdesc:ga3657b99a9667945373e520dbac0f4516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Q15 matrix multiplication.  <a href="#ga3657b99a9667945373e520dbac0f4516">More...</a><br /></td></tr>
<tr class="separator:ga3657b99a9667945373e520dbac0f4516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec612a8c2c4916477fb9bc1ab548a6e"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___matrix_mult.html#ga2ec612a8c2c4916477fb9bc1ab548a6e">arm_mat_mult_q31</a> (const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pSrcA, const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pSrcB, <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *pDst)</td></tr>
<tr class="memdesc:ga2ec612a8c2c4916477fb9bc1ab548a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Q31 matrix multiplication.  <a href="#ga2ec612a8c2c4916477fb9bc1ab548a6e">More...</a><br /></td></tr>
<tr class="separator:ga2ec612a8c2c4916477fb9bc1ab548a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Multiplies two matrices.</p>
<div class="image">
<img src="MatrixMultiplication.gif" alt="MatrixMultiplication.gif"/>
<div class="caption">
Multiplication of two 3 x 3 matrices</div></div>
<p> Matrix multiplication is only defined if the number of columns of the first matrix equals the number of rows of the second matrix. Multiplying an <code>M x N</code> matrix with an <code>N x P</code> matrix results in an <code>M x P</code> matrix. When matrix size checking is enabled, the functions check: (1) that the inner dimensions of <code>pSrcA</code> and <code>pSrcB</code> are equal; and (2) that the size of the output matrix equals the outer dimensions of <code>pSrcA</code> and <code>pSrcB</code>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga917bf0270310c1d3f0eda1fc7c0026a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_mat_mult_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__matrix__instance__f32.html">arm_matrix_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floating-point matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input matrix structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to output matrix structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns either <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking. </dd></dl>
<p>input data matrix pointer A</p>
<p>input data matrix pointer B</p>
<p>input data matrix pointer A</p>
<p>output data matrix pointer</p>
<p>Temporary output data matrix pointer</p>
<p>Accumulator</p>
<p>number of rows of input matrix A</p>
<p>number of columns of input matrix B</p>
<p>number of columns of input matrix A</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>loop counters</p>
<p>status of matrix multiplication</p>
<p>The following loop performs the dot-product of each row in pSrcA with each column in pSrcB</p>
<p>row loop</p>
<p>Output pointer is set to starting address of the row being processed</p>
<p>For every row wise process, the column loop counter is to be initiated</p>
<p>For every row wise process, the pIn2 pointer is set to the starting address of the pSrcB data</p>
<p>column loop</p>
<p>Set the variable sum, that acts as accumulator, to zero</p>
<p>Initiate the pointer pIn1 to point to the starting address of the column being processed</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>matrix multiplication</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Decrement the loop count</p>
<p>If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Decrement the loop counter</p>
<p>Store the result in the destination buffer</p>
<p>Update the pointer pIn2 to point to the starting address of the next column</p>
<p>Decrement the column loop counter</p>
<p>Update the pointer pInA to point to the starting address of the next row</p>
<p>Decrement the row loop counter</p>
<p>Set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__mat__mult__f32_8c_source.html#l00078">78</a> of file <a class="el" href="arm__mat__mult__f32_8c_source.html">arm_mat_mult_f32.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l01372">arm_matrix_instance_f32::numCols</a>, <a class="el" href="arm__math_8h_source.html#l01371">arm_matrix_instance_f32::numRows</a>, and <a class="el" href="arm__math_8h_source.html#l01373">arm_matrix_instance_f32::pData</a>.</p>

</div>
</div>
<a class="anchor" id="ga08f37d93a5bfef0c5000dc5e0a411f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_mat_mult_fast_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input matrix structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to output matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to the array for storing intermediate results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns either <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The difference between the function <a class="el" href="group___matrix_mult.html#ga3657b99a9667945373e520dbac0f4516" title="Q15 matrix multiplication. ">arm_mat_mult_q15()</a> and this fast variant is that the fast variant use a 32-bit rather than a 64-bit accumulator. The result of each 1.15 x 1.15 multiplication is truncated to 2.30 format. These intermediate results are accumulated in a 32-bit register in 2.30 format. Finally, the accumulator is saturated and converted to a 1.15 result.</dd></dl>
<dl class="section user"><dt></dt><dd>The fast version has the same overflow behavior as the standard version but provides less precision since it discards the low 16 bits of each multiplication result. In order to avoid overflows completely the input signals must be scaled down. Scale down one of the input matrices by log2(numColsA) bits to avoid overflows, as a total of numColsA additions are computed internally for each output element.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___matrix_mult.html#ga3657b99a9667945373e520dbac0f4516" title="Q15 matrix multiplication. ">arm_mat_mult_q15()</a></code> for a slower implementation of this function which uses 64-bit accumulation to provide higher precision. </dd></dl>
<p>accumulator</p>
<p>input data matrix pointer for transpose</p>
<p>input data matrix pointer A of Q15 type</p>
<p>input data matrix pointer B of Q15 type</p>
<p>Temporary output data matrix pointer</p>
<p>number of rows of input matrix A</p>
<p>number of columns of input matrix B</p>
<p>number of columns of input matrix A</p>
<p>number of rows of input matrix A</p>
<p>loop counters</p>
<p>status of matrix multiplication</p>
<p>Temporary variable to hold the input value</p>
<p>Matrix transpose</p>
<p>Apply loop unrolling and exchange the columns with row elements</p>
<p>The pointer px is set to starting address of the column being processed</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Read two elements from the row</p>
<p>Unpack and store one element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Unpack and store the second element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Read two elements from the row</p>
<p>Unpack and store one element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Unpack and store the second element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Decrement the column loop counter</p>
<p>If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Read and store the input element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Decrement the column loop counter</p>
<p>Decrement the row loop counter</p>
<p>Reset the variables for the usage in the following multiplication process</p>
<p>The following loop performs the dot-product of each row in pSrcA with each column in pSrcB</p>
<p>row loop</p>
<p>For every row wise process, the column loop counter is to be initiated</p>
<p>For every row wise process, the pIn2 pointer is set to the starting address of the transposed pSrcB data</p>
<p>column loop</p>
<p>Set the variable sum, that acts as accumulator, to zero</p>
<p>Apply loop unrolling and compute 2 MACs simultaneously.</p>
<p>Initiate the pointer pIn1 to point to the starting address of the column being processed</p>
<p>matrix multiplication</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Decrement the loop counter</p>
<p>process odd column samples</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Saturate and store the result in the destination buffer</p>
<p>Decrement the column loop counter</p>
<p>Decrement the row loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__mat__mult__fast__q15_8c_source.html#l00085">85</a> of file <a class="el" href="arm__mat__mult__fast__q15_8c_source.html">arm_mat_mult_fast_q15.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l01393">arm_matrix_instance_q15::numCols</a>, <a class="el" href="arm__math_8h_source.html#l01392">arm_matrix_instance_q15::numRows</a>, and <a class="el" href="arm__math_8h_source.html#l01394">arm_matrix_instance_q15::pData</a>.</p>

</div>
</div>
<a class="anchor" id="ga2785e8c1b785348b0c439b56aaf585a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_mat_mult_fast_q31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input matrix structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to output matrix structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns either <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The difference between the function <a class="el" href="group___matrix_mult.html#ga2ec612a8c2c4916477fb9bc1ab548a6e" title="Q31 matrix multiplication. ">arm_mat_mult_q31()</a> and this fast variant is that the fast variant use a 32-bit rather than a 64-bit accumulator. The result of each 1.31 x 1.31 multiplication is truncated to 2.30 format. These intermediate results are accumulated in a 32-bit register in 2.30 format. Finally, the accumulator is saturated and converted to a 1.31 result.</dd></dl>
<dl class="section user"><dt></dt><dd>The fast version has the same overflow behavior as the standard version but provides less precision since it discards the low 32 bits of each multiplication result. In order to avoid overflows completely the input signals must be scaled down. Scale down one of the input matrices by log2(numColsA) bits to avoid overflows, as a total of numColsA additions are computed internally for each output element.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___matrix_mult.html#ga2ec612a8c2c4916477fb9bc1ab548a6e" title="Q31 matrix multiplication. ">arm_mat_mult_q31()</a></code> for a slower implementation of this function which uses 64-bit accumulation to provide higher precision. </dd></dl>
<p>input data matrix pointer A</p>
<p>input data matrix pointer B</p>
<p>input data matrix pointer A</p>
<p>output data matrix pointer</p>
<p>Temporary output data matrix pointer</p>
<p>Accumulator</p>
<p>number of rows of input matrix A</p>
<p>number of columns of input matrix B</p>
<p>number of columns of input matrix A</p>
<p>loop counters</p>
<p>status of matrix multiplication</p>
<p>The following loop performs the dot-product of each row in pSrcA with each column in pSrcB</p>
<p>row loop</p>
<p>Output pointer is set to starting address of the row being processed</p>
<p>For every row wise process, the column loop counter is to be initiated</p>
<p>For every row wise process, the pIn2 pointer is set to the starting address of the pSrcB data</p>
<p>column loop</p>
<p>Set the variable sum, that acts as accumulator, to zero</p>
<p>Initiate the pointer pIn1 to point to the starting address of pInA</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>matrix multiplication</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Convert the result from 2.30 to 1.31 format and store in destination buffer</p>
<p>Update the pointer pIn2 to point to the starting address of the next column</p>
<p>Decrement the column loop counter</p>
<p>Update the pointer pInA to point to the starting address of the next row</p>
<p>Decrement the row loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__mat__mult__fast__q31_8c_source.html#l00083">83</a> of file <a class="el" href="arm__mat__mult__fast__q31_8c_source.html">arm_mat_mult_fast_q31.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l01403">arm_matrix_instance_q31::numCols</a>, <a class="el" href="arm__math_8h_source.html#l01402">arm_matrix_instance_q31::numRows</a>, and <a class="el" href="arm__math_8h_source.html#l01404">arm_matrix_instance_q31::pData</a>.</p>

</div>
</div>
<a class="anchor" id="ga3657b99a9667945373e520dbac0f4516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_mat_mult_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__matrix__instance__q15.html">arm_matrix_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *pState&#160;</td>
          <td class="paramname"><em>CMSIS_UNUSED</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Q15 matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input matrix structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to output matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to the array for storing intermediate results (Unused) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns either <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. The inputs to the multiplications are in 1.15 format and multiplications yield a 2.30 result. The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format. This approach provides 33 guard bits and there is no risk of overflow. The 34.30 result is then truncated to 34.15 format by discarding the low 15 bits and then saturated to 1.15 format.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <code><a class="el" href="group___matrix_mult.html#ga08f37d93a5bfef0c5000dc5e0a411f93" title="Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4. ">arm_mat_mult_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4. </dd></dl>
<p>accumulator</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>input data matrix pointer for transpose</p>
<p>input data matrix pointer A of Q15 type</p>
<p>input data matrix pointer B of Q15 type</p>
<p>Temporary output data matrix pointer</p>
<p>number of rows of input matrix A</p>
<p>number of columns of input matrix B</p>
<p>number of columns of input matrix A</p>
<p>number of rows of input matrix A</p>
<p>loop counters</p>
<p>status of matrix multiplication</p>
<p>Temporary variable to hold the input value</p>
<p>Matrix transpose</p>
<p>Apply loop unrolling and exchange the columns with row elements</p>
<p>The pointer px is set to starting address of the column being processed</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Read two elements from the row</p>
<p>Unpack and store one element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Unpack and store the second element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Read two elements from the row</p>
<p>Unpack and store one element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Unpack and store the second element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Decrement the column loop counter</p>
<p>If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Read and store the input element in the destination</p>
<p>Update the pointer px to point to the next row of the transposed matrix</p>
<p>Decrement the column loop counter</p>
<p>Decrement the row loop counter</p>
<p>Reset the variables for the usage in the following multiplication process</p>
<p>The following loop performs the dot-product of each row in pSrcA with each column in pSrcB</p>
<p>row loop</p>
<p>For every row wise process, the column loop counter is to be initiated</p>
<p>For every row wise process, the pIn2 pointer is set to the starting address of the transposed pSrcB data</p>
<p>column loop</p>
<p>Set the variable sum, that acts as accumulator, to zero</p>
<p>Apply loop unrolling and compute 2 MACs simultaneously.</p>
<p>Initiate the pointer pIn1 to point to the starting address of the column being processed</p>
<p>matrix multiplication</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>read real and imag values from pSrcA and pSrcB buffer</p>
<p>Multiply and Accumlates</p>
<p>Decrement the loop counter</p>
<p>process remaining column samples</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Decrement the loop counter</p>
<p>Saturate and store the result in the destination buffer</p>
<p>Decrement the column loop counter</p>
<p>Decrement the row loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__mat__mult__q15_8c_source.html#l00079">79</a> of file <a class="el" href="arm__mat__mult__q15_8c_source.html">arm_mat_mult_q15.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l01393">arm_matrix_instance_q15::numCols</a>, <a class="el" href="arm__math_8h_source.html#l01392">arm_matrix_instance_q15::numRows</a>, and <a class="el" href="arm__math_8h_source.html#l01394">arm_matrix_instance_q15::pData</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ec612a8c2c4916477fb9bc1ab548a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_mat_mult_q31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__matrix__instance__q31.html">arm_matrix_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Q31 matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input matrix structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input matrix structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to output matrix structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns either <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using an internal 64-bit accumulator. The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit. There is no saturation on intermediate additions. Thus, if the accumulator overflows it wraps around and distorts the result. The input signals should be scaled down to avoid intermediate overflows. The input is thus scaled down by log2(numColsA) bits to avoid overflows, as a total of numColsA additions are performed internally. The 2.62 accumulator is right shifted by 31 bits and saturated to 1.31 format to yield the final result.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___matrix_mult.html#ga2785e8c1b785348b0c439b56aaf585a3" title="Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4. ">arm_mat_mult_fast_q31()</a></code> for a faster but less precise implementation of this function for Cortex-M3 and Cortex-M4. </dd></dl>
<p>input data matrix pointer A</p>
<p>input data matrix pointer B</p>
<p>input data matrix pointer A</p>
<p>output data matrix pointer</p>
<p>Temporary output data matrix pointer</p>
<p>Accumulator</p>
<p>number of rows of input matrix A</p>
<p>number of columns of input matrix B</p>
<p>number of columns of input matrix A</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>loop counters</p>
<p>status of matrix multiplication</p>
<p>The following loop performs the dot-product of each row in pSrcA with each column in pSrcB</p>
<p>row loop</p>
<p>Output pointer is set to starting address of the row being processed</p>
<p>For every row wise process, the column loop counter is to be initiated</p>
<p>For every row wise process, the pIn2 pointer is set to the starting address of the pSrcB data</p>
<p>column loop</p>
<p>Set the variable sum, that acts as accumulator, to zero</p>
<p>Initiate the pointer pIn1 to point to the starting address of pInA</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>matrix multiplication</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n)</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Convert the result from 2.62 to 1.31 format and store in destination buffer</p>
<p>Update the pointer pIn2 to point to the starting address of the next column</p>
<p>Decrement the column loop counter</p>
<p>Update the pointer pInA to point to the starting address of the next row</p>
<p>Decrement the row loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__mat__mult__q31_8c_source.html#l00078">78</a> of file <a class="el" href="arm__mat__mult__q31_8c_source.html">arm_mat_mult_q31.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l01403">arm_matrix_instance_q31::numCols</a>, <a class="el" href="arm__math_8h_source.html#l01402">arm_matrix_instance_q31::numRows</a>, and <a class="el" href="arm__math_8h_source.html#l01404">arm_matrix_instance_q31::pData</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
