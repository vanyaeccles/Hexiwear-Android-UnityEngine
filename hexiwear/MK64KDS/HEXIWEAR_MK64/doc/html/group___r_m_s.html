<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Root mean square (RMS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m_s.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Root mean square (RMS)<div class="ingroups"><a class="el" href="group__group_stats.html">Statistics Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e3ab1b57da32d45388d1fa90d7fd88c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_s.html#ga0e3ab1b57da32d45388d1fa90d7fd88c">arm_rms_f32</a> (float32_t *pSrc, uint32_t blockSize, float32_t *pResult)</td></tr>
<tr class="memdesc:ga0e3ab1b57da32d45388d1fa90d7fd88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root Mean Square of the elements of a floating-point vector.  <a href="#ga0e3ab1b57da32d45388d1fa90d7fd88c">More...</a><br /></td></tr>
<tr class="separator:ga0e3ab1b57da32d45388d1fa90d7fd88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b836b72dda9e5dfbbd17c7906fd13f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_s.html#gaf5b836b72dda9e5dfbbd17c7906fd13f">arm_rms_q15</a> (q15_t *pSrc, uint32_t blockSize, q15_t *pResult)</td></tr>
<tr class="memdesc:gaf5b836b72dda9e5dfbbd17c7906fd13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root Mean Square of the elements of a Q15 vector.  <a href="#gaf5b836b72dda9e5dfbbd17c7906fd13f">More...</a><br /></td></tr>
<tr class="separator:gaf5b836b72dda9e5dfbbd17c7906fd13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33015fda23fc44e7ead5e5ed7e8d314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_m_s.html#gae33015fda23fc44e7ead5e5ed7e8d314">arm_rms_q31</a> (q31_t *pSrc, uint32_t blockSize, q31_t *pResult)</td></tr>
<tr class="memdesc:gae33015fda23fc44e7ead5e5ed7e8d314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root Mean Square of the elements of a Q31 vector.  <a href="#gae33015fda23fc44e7ead5e5ed7e8d314">More...</a><br /></td></tr>
<tr class="separator:gae33015fda23fc44e7ead5e5ed7e8d314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Calculates the Root Mean Sqaure of the elements in the input vector. The underlying algorithm is used:</p>
<pre>
    Result = sqrt(((pSrc[0] * pSrc[0] + pSrc[1] * pSrc[1] + ... + pSrc[blockSize-1] * pSrc[blockSize-1]) / blockSize));
</pre><p>There are separate functions for floating point, Q31, and Q15 data types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0e3ab1b57da32d45388d1fa90d7fd88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_rms_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root Mean Square of the elements of a floating-point vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>rms value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Accumulator</p>
<p>Tempoprary variable to store input value</p>
<p>loop counter</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>loop Unrolling</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute sum of the squares and then store the result in a temporary variable, sum</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute sum of the squares and then store the results in a temporary variable, sum</p>
<p>Decrement the loop counter</p>
<p>Compute Rms and store the result in the destination </p>

<p>Definition at line <a class="el" href="arm__rms__f32_8c_source.html#l00076">76</a> of file <a class="el" href="arm__rms__f32_8c_source.html">arm_rms_f32.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5b836b72dda9e5dfbbd17c7906fd13f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_rms_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root Mean Square of the elements of a Q15 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>rms value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. The input is represented in 1.15 format. Intermediate multiplication yields a 2.30 format, and this result is added without saturation to a 64-bit accumulator in 34.30 format. With 33 guard bits in the accumulator, there is no risk of overflow, and the full precision of the intermediate multiplication is preserved. Finally, the 34.30 result is truncated to 34.15 format by discarding the lower 15 bits, and then saturated to yield a result in 1.15 format. </dd></dl>
<p>accumulator</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>temporary variable to store the input value</p>
<p>temporary variable to store the input value</p>
<p>loop counter</p>
<p>loop Unrolling</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>C = (A[0] * A[0] + A[1] * A[1] + ... + A[blockSize-1] * A[blockSize-1])</p>
<p>Compute sum of the squares and then store the results in a temporary variable, sum</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = (A[0] * A[0] + A[1] * A[1] + ... + A[blockSize-1] * A[blockSize-1])</p>
<p>Compute sum of the squares and then store the results in a temporary variable, sum</p>
<p>Decrement the loop counter</p>
<p>Truncating and saturating the accumulator to 1.15 format</p>
<p>Store the result in the destination </p>

<p>Definition at line <a class="el" href="arm__rms__q15_8c_source.html#l00070">70</a> of file <a class="el" href="arm__rms__q15_8c_source.html">arm_rms_q15.c</a>.</p>

<p>References <a class="el" href="arm__sqrt__q15_8c_source.html#l00062">arm_sqrt_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="gae33015fda23fc44e7ead5e5ed7e8d314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_rms_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Root Mean Square of the elements of a Q31 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>rms value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using an internal 64-bit accumulator. The input is represented in 1.31 format, and intermediate multiplication yields a 2.62 format. The accumulator maintains full precision of the intermediate multiplication results, but provides only a single guard bit. There is no saturation on intermediate additions. If the accumulator overflows, it wraps around and distorts the result. In order to avoid overflows completely, the input signal must be scaled down by log2(blockSize) bits, as a total of blockSize additions are performed internally. Finally, the 2.62 accumulator is right shifted by 31 bits to yield a 1.31 format value. </dd></dl>
<p>accumulator</p>
<p>Temporary variable to store the input</p>
<p>loop counter</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Temporary input variables</p>
<p>First part of the processing with loop unrolling. Compute 8 outputs at a time. a second loop below computes the remaining 1 to 7 samples.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute sum of the squares and then store the result in a temporary variable, sum</p>
<p>read two samples from source buffer</p>
<p>calculate power and accumulate to accumulator</p>
<p>read two samples from source buffer</p>
<p>calculate power and accumulate to accumulator</p>
<p>update source buffer to process next samples</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 8, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute sum of the squares and then store the results in a temporary variable, sum</p>
<p>Decrement the loop counter</p>
<p>Convert data in 2.62 to 1.31 by 31 right shifts and saturate</p>
<p>Compute Rms and store the result in the destination vector </p>

<p>Definition at line <a class="el" href="arm__rms__q31_8c_source.html#l00073">73</a> of file <a class="el" href="arm__rms__q31_8c_source.html">arm_rms_q31.c</a>.</p>

<p>References <a class="el" href="arm__sqrt__q31_8c_source.html#l00061">arm_sqrt_q31()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
