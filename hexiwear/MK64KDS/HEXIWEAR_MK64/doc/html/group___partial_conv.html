<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Partial Convolution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___partial_conv.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Partial Convolution<div class="ingroups"><a class="el" href="group__group_filters.html">Filtering Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16d10f32072cd79fc5fb6e785df45f5e"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga16d10f32072cd79fc5fb6e785df45f5e">arm_conv_partial_f32</a> (float32_t *pSrcA, uint32_t srcALen, float32_t *pSrcB, uint32_t srcBLen, float32_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga16d10f32072cd79fc5fb6e785df45f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of floating-point sequences.  <a href="#ga16d10f32072cd79fc5fb6e785df45f5e">More...</a><br /></td></tr>
<tr class="separator:ga16d10f32072cd79fc5fb6e785df45f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de9c4ddcc7886de25b70d875099a8d9"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga3de9c4ddcc7886de25b70d875099a8d9">arm_conv_partial_fast_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, uint32_t firstIndex, uint32_t numPoints, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:ga3de9c4ddcc7886de25b70d875099a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#ga3de9c4ddcc7886de25b70d875099a8d9">More...</a><br /></td></tr>
<tr class="separator:ga3de9c4ddcc7886de25b70d875099a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4d43385cb62262a78c6752fe1fafb2"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga1e4d43385cb62262a78c6752fe1fafb2">arm_conv_partial_fast_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga1e4d43385cb62262a78c6752fe1fafb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#ga1e4d43385cb62262a78c6752fe1fafb2">More...</a><br /></td></tr>
<tr class="separator:ga1e4d43385cb62262a78c6752fe1fafb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c5294cda8c4985386f4e3944be7650"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga10c5294cda8c4985386f4e3944be7650">arm_conv_partial_fast_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga10c5294cda8c4985386f4e3944be7650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#ga10c5294cda8c4985386f4e3944be7650">More...</a><br /></td></tr>
<tr class="separator:ga10c5294cda8c4985386f4e3944be7650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834b23b4ade8682beeb55778399101f8"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga834b23b4ade8682beeb55778399101f8">arm_conv_partial_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, uint32_t firstIndex, uint32_t numPoints, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:ga834b23b4ade8682beeb55778399101f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q15 sequences.  <a href="#ga834b23b4ade8682beeb55778399101f8">More...</a><br /></td></tr>
<tr class="separator:ga834b23b4ade8682beeb55778399101f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3707e16af1435b215840006a7ab0c98f"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga3707e16af1435b215840006a7ab0c98f">arm_conv_partial_opt_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst, uint32_t firstIndex, uint32_t numPoints, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:ga3707e16af1435b215840006a7ab0c98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q7 sequences.  <a href="#ga3707e16af1435b215840006a7ab0c98f">More...</a><br /></td></tr>
<tr class="separator:ga3707e16af1435b215840006a7ab0c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209a2a913a0c5e5679c5988da8f46b03"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga209a2a913a0c5e5679c5988da8f46b03">arm_conv_partial_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga209a2a913a0c5e5679c5988da8f46b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q15 sequences.  <a href="#ga209a2a913a0c5e5679c5988da8f46b03">More...</a><br /></td></tr>
<tr class="separator:ga209a2a913a0c5e5679c5988da8f46b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e73a5f02d103168a09821fb461e77a"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga78e73a5f02d103168a09821fb461e77a">arm_conv_partial_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga78e73a5f02d103168a09821fb461e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q31 sequences.  <a href="#ga78e73a5f02d103168a09821fb461e77a">More...</a><br /></td></tr>
<tr class="separator:ga78e73a5f02d103168a09821fb461e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8567259fe18396dd972242c41741ebf4"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___partial_conv.html#ga8567259fe18396dd972242c41741ebf4">arm_conv_partial_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst, uint32_t firstIndex, uint32_t numPoints)</td></tr>
<tr class="memdesc:ga8567259fe18396dd972242c41741ebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial convolution of Q7 sequences.  <a href="#ga8567259fe18396dd972242c41741ebf4">More...</a><br /></td></tr>
<tr class="separator:ga8567259fe18396dd972242c41741ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Partial Convolution is equivalent to Convolution except that a subset of the output samples is generated. Each function has two additional arguments. <code>firstIndex</code> specifies the starting index of the subset of output samples. <code>numPoints</code> is the number of output samples to compute. The function computes the output in the range <code>[firstIndex, ..., firstIndex+numPoints-1]</code>. The output array <code>pDst</code> contains <code>numPoints</code> values.</p>
<p>The allowable range of output indices is [0 srcALen+srcBLen-2]. If the requested subset does not fall in this range then the functions return ARM_MATH_ARGUMENT_ERROR. Otherwise the functions return ARM_MATH_SUCCESS. </p><dl class="section note"><dt>Note</dt><dd>Refer <a class="el" href="group___conv.html#ga3f860dc98c6fc4cafc421e4a2aed3c89" title="Convolution of floating-point sequences. ">arm_conv_f32()</a> for details on fixed point behavior.</dd></dl>
<p><b>Fast Versions</b></p>
<dl class="section user"><dt></dt><dd>Fast versions are supported for Q31 and Q15 of partial convolution. Cycles for Fast versions are less compared to Q31 and Q15 of partial conv and the design requires the input signals should be scaled down to avoid intermediate overflows.</dd></dl>
<p><b>Opt Versions</b></p>
<dl class="section user"><dt></dt><dd>Opt versions are supported for Q15 and Q7. Design uses internal scratch buffer for getting good optimisation. These versions are optimised in cycles and consumes more memory(Scratch memory) compared to Q15 and Q7 versions of partial convolution </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga16d10f32072cd79fc5fb6e785df45f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of floating-point sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]. </dd></dl>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulator</p>
<p>Temporary variables to hold state and coefficient values</p>
<p>loop counters</p>
<p>status of Partial convolution</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Conditions to check which loopCounter holds the first and last indices of the output samples to be calculated.</p>
<p>conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1]</p>
<p>The function is internally divided into three stages according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first stage of the algorithm, the multiplications increase by one for every iteration. In the second stage of the algorithm, srcBLen number of multiplications are done. In the third stage of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>Set the output pointer to point to the firstIndex of the output sample to be calculated.</p>
<p>sum = x[0] * y[0] sum = x[0] * y[1] + x[1] * y[0] .... sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed. Since the partial convolution starts from from firstIndex Number of Macs to be performed is firstIndex + 1</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>x[1] * y[srcBLen - 2]</p>
<p>x[2] * y[srcBLen - 3]</p>
<p>x[3] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0] sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0] .... sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[srcBLen - 1] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[0] * y[srcBLen - 1]</p>
<p>acc1 += x[1] * y[srcBLen - 1]</p>
<p>acc2 += x[2] * y[srcBLen - 1]</p>
<p>acc3 += x[3] * y[srcBLen - 1]</p>
<p>Read y[srcBLen - 2] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[1] * y[srcBLen - 2]</p>
<p>acc1 += x[2] * y[srcBLen - 2]</p>
<p>acc2 += x[3] * y[srcBLen - 2]</p>
<p>acc3 += x[4] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 3] sample</p>
<p>Read x[5] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[srcBLen - 3]</p>
<p>acc1 += x[3] * y[srcBLen - 2]</p>
<p>acc2 += x[4] * y[srcBLen - 2]</p>
<p>acc3 += x[5] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 4] sample</p>
<p>Read x[6] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[3] * y[srcBLen - 4]</p>
<p>acc1 += x[4] * y[srcBLen - 4]</p>
<p>acc2 += x[5] * y[srcBLen - 4]</p>
<p>acc3 += x[6] * y[srcBLen - 4]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[srcBLen - 5] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[srcBLen - 5]</p>
<p>acc1 += x[5] * y[srcBLen - 5]</p>
<p>acc2 += x[6] * y[srcBLen - 5]</p>
<p>acc3 += x[7] * y[srcBLen - 5]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>srcBLen number of MACS should be performed</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1] sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2] .... sum += x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2] sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3]</p>
<p>sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__f32_8c_source.html#l00095">95</a> of file <a class="el" href="arm__conv__partial__f32_8c_source.html">arm_conv_partial_f32.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3de9c4ddcc7886de25b70d875099a8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_fast_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer of size min(srcALen, srcBLen). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<p>See <code><a class="el" href="group___partial_conv.html#ga209a2a913a0c5e5679c5988da8f46b03" title="Partial convolution of Q15 sequences. ">arm_conv_partial_q15()</a></code> for a slower implementation of this function which uses a 64-bit accumulator to avoid wrap around distortion.</p>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit </dd></dl>
<p>output pointer</p>
<p>Temporary pointer for scratch1</p>
<p>Temporary pointer for scratch1</p>
<p>Accumulator</p>
<p>Temporary variables to hold state and coefficient values</p>
<p>State variables</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>loop counter</p>
<p>loop count</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Temporary pointer for scratch2</p>
<p>pointer to take end of scratch2 buffer</p>
<p>points to smaller length sequence</p>
<p>Apply loop unrolling and do 4 Copies simultaneously.</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>Copy smaller length input sequence in reverse order into second scratch buffer</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Initialze temporary scratch pointer</p>
<p>Assuming scratch1 buffer is aligned by 32-bit</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy bigger length sequence(srcALen) samples in scratch1 buffer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>Update pointers</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Initialization of pIn2 pointer</p>
<p>First part of the processing with loop unrolling process 4 data points at a time. a second loop below process for the remaining 1 to 3 samples.</p>
<p>Actual convolution process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read two samples from scratch1 buffer</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>multiply and accumlate</p>
<p>Read next two samples from scratch1 buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>update scratch pointers</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the results in the accumulators in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate convolution for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read two samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>The result is in 2.30 format. Convert to 1.15 with saturation. Then store the output in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__fast__opt__q15_8c_source.html#l00075">75</a> of file <a class="el" href="arm__conv__partial__fast__opt__q15_8c_source.html">arm_conv_partial_fast_opt_q15.c</a>.</p>

<p>References <a class="el" href="arm__conv__partial__fast__opt__q15_8c_source.html#l00075">arm_conv_partial_fast_opt_q15()</a>, <a class="el" href="arm__copy__q15_8c_source.html#l00060">arm_copy_q15()</a>, and <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

<p>Referenced by <a class="el" href="arm__conv__partial__fast__opt__q15_8c_source.html#l00075">arm_conv_partial_fast_opt_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e4d43385cb62262a78c6752fe1fafb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_fast_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<p>See <code><a class="el" href="group___partial_conv.html#ga209a2a913a0c5e5679c5988da8f46b03" title="Partial convolution of Q15 sequences. ">arm_conv_partial_q15()</a></code> for a slower implementation of this function which uses a 64-bit accumulator to avoid wrap around distortion. </p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Accumulator</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>loop counters</p>
<p>status of Partial convolution</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Conditions to check which loopCounter holds the first and last indices of the output samples to be calculated.</p>
<p>conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1]</p>
<p>The function is internally divided into three stages according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first stage of the algorithm, the multiplications increase by one for every iteration. In the second stage of the algorithm, srcBLen number of multiplications are done. In the third stage of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>Set the output pointer to point to the firstIndex of the output sample to be calculated.</p>
<p>sum = x[0] * y[0] sum = x[0] * y[1] + x[1] * y[0] .... sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed. Since the partial convolution starts from firstIndex Number of Macs to be performed is firstIndex + 1</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>For loop unrolling by 4, this stage is divided into two.</p>
<p>First part of this stage computes the MAC operations less than 4</p>
<p>Second part of this stage computes the MAC operations greater than or equal to 4</p>
<p>The first part of the stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over number of MAC operations between inputA samples and inputB samples</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>The second part of the stage starts here</p>
<p>The internal loop, over count, is unrolled by 4</p>
<p>To, read the last two inputB samples using SIMD: y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively</p>
<p>x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively</p>
<p>Decrement the loop counter</p>
<p>For the next MAC operations, the pointer py is used without SIMD So, py is incremented by 1</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0] sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0] .... sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is the index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1] samples</p>
<p>read x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read the last two inputB samples using SIMD: y[srcBLen - 1] and y[srcBLen - 2]</p>
<p>acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]</p>
<p>acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]</p>
<p>Read x[2], x[3]</p>
<p>Read x[3], x[4]</p>
<p>acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]</p>
<p>acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 3] and y[srcBLen - 4]</p>
<p>acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]</p>
<p>acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]</p>
<p>Read x[4], x[5]</p>
<p>Read x[5], x[6]</p>
<p>acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]</p>
<p>acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]</p>
<p>For the next MAC operations, SIMD is not used So, the 16 bit pointer if inputB, py is updated</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[srcBLen - 5]</p>
<p>Read x[7]</p>
<p>Perform the multiply-accumulates</p>
<p>Read y[srcBLen - 5], y[srcBLen - 6]</p>
<p>Read x[7], x[8]</p>
<p>Read x[9]</p>
<p>Perform the multiply-accumulates</p>
<p>Read y[srcBLen - 5], y[srcBLen - 6]</p>
<p>Read x[7], x[8]</p>
<p>Read x[9]</p>
<p>Perform the multiply-accumulates</p>
<p>Read x[10]</p>
<p>Perform the multiply-accumulates</p>
<p>Store the results in the accumulators in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 4</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>srcBLen number of MACS should be performed</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1] sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2] .... sum += x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2] sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>For loop unrolling by 4, this stage is divided into two.</p>
<p>First part of this stage computes the MAC operations greater than 4</p>
<p>Second part of this stage computes the MAC operations less than or equal to 4</p>
<p>The first part of the stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively</p>
<p>x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively</p>
<p>Decrement the loop counter</p>
<p>For the next MAC operations, the pointer py is used without SIMD So, py is incremented by 1</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>The second part of the stage starts here</p>
<p>SIMD is not used for the next MAC operations, so pointer py is updated to read only one sample at a time</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__fast__q15_8c_source.html#l00067">67</a> of file <a class="el" href="arm__conv__partial__fast__q15_8c_source.html">arm_conv_partial_fast_q15.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga10c5294cda8c4985386f4e3944be7650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_fast_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___partial_conv.html#ga78e73a5f02d103168a09821fb461e77a" title="Partial convolution of Q31 sequences. ">arm_conv_partial_q31()</a></code> for a slower implementation of this function which uses a 64-bit accumulator to provide higher precision. </dd></dl>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulators</p>
<p>loop counters</p>
<p>status of Partial convolution</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Conditions to check which loopCounter holds the first and last indices of the output samples to be calculated.</p>
<p>conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1]</p>
<p>The function is internally divided into three stages according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first stage of the algorithm, the multiplications increase by one for every iteration. In the second stage of the algorithm, srcBLen number of multiplications are done. In the third stage of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>Set the output pointer to point to the firstIndex of the output sample to be calculated.</p>
<p>sum = x[0] * y[0] sum = x[0] * y[1] + x[1] * y[0] .... sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed. Since the partial convolution starts from firstIndex Number of Macs to be performed is firstIndex + 1</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first loop starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>x[1] * y[srcBLen - 2]</p>
<p>x[2] * y[srcBLen - 3]</p>
<p>x[3] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0] sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0] .... sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[srcBLen - 1] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[0] * y[srcBLen - 1]</p>
<p>acc1 += x[1] * y[srcBLen - 1]</p>
<p>acc2 += x[2] * y[srcBLen - 1]</p>
<p>acc3 += x[3] * y[srcBLen - 1]</p>
<p>Read y[srcBLen - 2] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[1] * y[srcBLen - 2]</p>
<p>acc1 += x[2] * y[srcBLen - 2]</p>
<p>acc2 += x[3] * y[srcBLen - 2]</p>
<p>acc3 += x[4] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 3] sample</p>
<p>Read x[5] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[srcBLen - 3]</p>
<p>acc1 += x[3] * y[srcBLen - 2]</p>
<p>acc2 += x[4] * y[srcBLen - 2]</p>
<p>acc3 += x[5] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 4] sample</p>
<p>Read x[6] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[3] * y[srcBLen - 4]</p>
<p>acc1 += x[4] * y[srcBLen - 4]</p>
<p>acc2 += x[5] * y[srcBLen - 4]</p>
<p>acc3 += x[6] * y[srcBLen - 4]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[srcBLen - 5] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[srcBLen - 5]</p>
<p>acc1 += x[5] * y[srcBLen - 5]</p>
<p>acc2 += x[6] * y[srcBLen - 5]</p>
<p>acc3 += x[7] * y[srcBLen - 5]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 4</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>srcBLen number of MACS should be performed</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1] sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2] .... sum += x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2] sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3]</p>
<p>sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__fast__q31_8c_source.html#l00067">67</a> of file <a class="el" href="arm__conv__partial__fast__q31_8c_source.html">arm_conv_partial_fast_q31.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga834b23b4ade8682beeb55778399101f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q15 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer of size min(srcALen, srcBLen). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, state buffers should be aligned by 32-bit</dd></dl>
<p>Refer to <code><a class="el" href="group___partial_conv.html#ga1e4d43385cb62262a78c6752fe1fafb2" title="Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_conv_partial_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4. </p>
<p>output pointer</p>
<p>Temporary pointer for scratch1</p>
<p>Temporary pointer for scratch1</p>
<p>Accumulator</p>
<p>Temporary variables to hold state and coefficient values</p>
<p>State variables</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>loop counter</p>
<p>Status variable</p>
<p>loop count</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Temporary pointer for scratch2</p>
<p>pointer to take end of scratch2 buffer</p>
<p>points to smaller length sequence</p>
<p>Apply loop unrolling and do 4 Copies simultaneously.</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Initialze temporary scratch pointer</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy bigger length sequence(srcALen) samples in scratch1 buffer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>Update pointers</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Initialization of pIn2 pointer</p>
<p>Actual convolution process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read two samples from scratch1 buffer</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>multiply and accumlate</p>
<p>Read next two samples from scratch1 buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>update scratch pointers</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the results in the accumulators in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate convolution for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read two samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__opt__q15_8c_source.html#l00076">76</a> of file <a class="el" href="arm__conv__partial__opt__q15_8c_source.html">arm_conv_partial_opt_q15.c</a>.</p>

<p>References <a class="el" href="arm__conv__partial__opt__q15_8c_source.html#l00076">arm_conv_partial_opt_q15()</a>, <a class="el" href="arm__copy__q15_8c_source.html#l00060">arm_copy_q15()</a>, and <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

<p>Referenced by <a class="el" href="arm__conv__partial__opt__q15_8c_source.html#l00076">arm_conv_partial_opt_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3707e16af1435b215840006a7ab0c98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_opt_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q7 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit </dd></dl>
<p>Intermediate pointers for scratch pointers</p>
<p>Temporary input variable</p>
<p>inputA and inputB pointer</p>
<p>loop counter</p>
<p>Temporary input1 pointer</p>
<p>Temporary input2 pointer</p>
<p>Accumulator</p>
<p>Temporary input variables</p>
<p>output pointer</p>
<p>temporary variables</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>pointer to take end of scratch2 buffer</p>
<p>points to smaller length sequence</p>
<p>Apply loop unrolling and do 4 Copies simultaneously.</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Initialze temporary scratch pointer</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>Apply loop unrolling and do 4 Copies simultaneously.</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Temporary pointer for scratch2</p>
<p>Initialization of pIn2 pointer</p>
<p>Actual convolution process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read two samples from scratch1 buffer</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>multiply and accumlate</p>
<p>Read next two samples from scratch1 buffer</p>
<p>pack input data</p>
<p>Read four samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate convolution for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read two samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>set status as ARM_MATH_SUCCESS </p>

<p>Definition at line <a class="el" href="arm__conv__partial__opt__q7_8c_source.html#l00076">76</a> of file <a class="el" href="arm__conv__partial__opt__q7_8c_source.html">arm_conv_partial_opt_q7.c</a>.</p>

<p>References <a class="el" href="arm__conv__partial__opt__q7_8c_source.html#l00076">arm_conv_partial_opt_q7()</a>, and <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

<p>Referenced by <a class="el" href="arm__conv__partial__opt__q7_8c_source.html#l00076">arm_conv_partial_opt_q7()</a>.</p>

</div>
</div>
<a class="anchor" id="ga209a2a913a0c5e5679c5988da8f46b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q15 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<p>Refer to <code><a class="el" href="group___partial_conv.html#ga1e4d43385cb62262a78c6752fe1fafb2" title="Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_conv_partial_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4.</p>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___partial_conv.html#ga834b23b4ade8682beeb55778399101f8" title="Partial convolution of Q15 sequences. ">arm_conv_partial_opt_q15()</a></code> for a faster implementation of this function using scratch buffers. </dd></dl>
<p>Run the below code for Cortex-M0</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Accumulator</p>
<p>loop counters</p>
<p>status of Partial convolution</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_ARGUMENT_ERROR</p>
<p>Loop to calculate convolution for output length number of values</p>
<p>Initialize sum with zero to carry on MAC operations</p>
<p>Loop to perform MAC operations according to convolution equation</p>
<p>Check the array limitations</p>
<p>z[i] += x[i-j] * y[j]</p>
<p>Store the output in the destination buffer</p>
<p>set status as ARM_SUCCESS as there are no argument errors </p>

<p>Definition at line <a class="el" href="arm__conv__partial__q15_8c_source.html#l00071">71</a> of file <a class="el" href="arm__conv__partial__q15_8c_source.html">arm_conv_partial_q15.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga78e73a5f02d103168a09821fb461e77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q31 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<p>See <code><a class="el" href="group___partial_conv.html#ga10c5294cda8c4985386f4e3944be7650" title="Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_conv_partial_fast_q31()</a></code> for a faster but less precise implementation of this function for Cortex-M3 and Cortex-M4. </p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulator</p>
<p>loop counter</p>
<p>status of Partial convolution</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Conditions to check which loopCounter holds the first and last indices of the output samples to be calculated.</p>
<p>conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1]</p>
<p>The function is internally divided into three stages according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first stage of the algorithm, the multiplications increase by one for every iteration. In the second stage of the algorithm, srcBLen number of multiplications are done. In the third stage of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>Set the output pointer to point to the firstIndex of the output sample to be calculated.</p>
<p>sum = x[0] * y[0] sum = x[0] * y[1] + x[1] * y[0] .... sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed. Since the partial convolution starts from firstIndex Number of Macs to be performed is firstIndex + 1</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first loop starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>x[1] * y[srcBLen - 2]</p>
<p>x[2] * y[srcBLen - 3]</p>
<p>x[3] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0] sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0] .... sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blkCnt</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1] samples</p>
<p>Apply loop unrolling and compute 3 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 3 MACs at a time. a second loop below computes MACs for the remaining 1 to 2 samples.</p>
<p>Read y[srcBLen - 1] sample</p>
<p>Read x[2] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[0] * y[srcBLen - 1]</p>
<p>acc1 += x[1] * y[srcBLen - 1]</p>
<p>acc2 += x[2] * y[srcBLen - 1]</p>
<p>Read y[srcBLen - 2] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[1] * y[srcBLen - 2]</p>
<p>acc1 += x[2] * y[srcBLen - 2]</p>
<p>acc2 += x[3] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 3] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[srcBLen - 3]</p>
<p>acc1 += x[3] * y[srcBLen - 2]</p>
<p>acc2 += x[4] * y[srcBLen - 2]</p>
<p>If the srcBLen is not a multiple of 3, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[srcBLen - 5] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[srcBLen - 5]</p>
<p>acc1 += x[5] * y[srcBLen - 5]</p>
<p>acc2 += x[6] * y[srcBLen - 5]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 3</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 3, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>srcBLen number of MACS should be performed</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1] sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2] .... sum += x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2] sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The blockSize3 variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Decrement the loop counter</p>
<p>If the blockSize3 is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__q31_8c_source.html#l00066">66</a> of file <a class="el" href="arm__conv__partial__q31_8c_source.html">arm_conv_partial_q31.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8567259fe18396dd972242c41741ebf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_conv_partial_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial convolution of Q7 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>is the first output sample to start with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPoints</td><td>is the number of output points to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].</dd></dl>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___partial_conv.html#ga3707e16af1435b215840006a7ab0c98f" title="Partial convolution of Q7 sequences. ">arm_conv_partial_opt_q7()</a></code> for a faster implementation of this function. </dd></dl>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulator</p>
<p>loop counter</p>
<p>Check for range of output samples to be calculated</p>
<p>Set status as ARM_MATH_ARGUMENT_ERROR</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>Conditions to check which loopCounter holds the first and last indices of the output samples to be calculated.</p>
<p>conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1]</p>
<p>The function is internally divided into three stages according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first stage of the algorithm, the multiplications increase by one for every iteration. In the second stage of the algorithm, srcBLen number of multiplications are done. In the third stage of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>Set the output pointer to point to the firstIndex of the output sample to be calculated.</p>
<p>sum = x[0] * y[0] sum = x[0] * y[1] + x[1] * y[0] .... sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed. Since the partial convolution starts from from firstIndex Number of Macs to be performed is firstIndex + 1</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] , x[1]</p>
<p>y[srcBLen - 1] , y[srcBLen - 2]</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>x[1] * y[srcBLen - 2]</p>
<p>x[2] , x[3]</p>
<p>y[srcBLen - 3] , y[srcBLen - 4]</p>
<p>x[2] * y[srcBLen - 3]</p>
<p>x[3] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0] sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0] .... sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[srcBLen - 1] sample</p>
<p>Read y[srcBLen - 2] sample</p>
<p>Read x[3] sample</p>
<p>x[0] and x[1] are packed</p>
<p>y[srcBLen - 1] and y[srcBLen - 2] are packed</p>
<p>acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]</p>
<p>x[1] and x[2] are packed</p>
<p>acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]</p>
<p>x[2] and x[3] are packed</p>
<p>acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]</p>
<p>Read x[4] sample</p>
<p>x[3] and x[4] are packed</p>
<p>acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]</p>
<p>Read y[srcBLen - 3] sample</p>
<p>Read y[srcBLen - 4] sample</p>
<p>Read x[5] sample</p>
<p>x[2] and x[3] are packed</p>
<p>y[srcBLen - 3] and y[srcBLen - 4] are packed</p>
<p>acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]</p>
<p>x[3] and x[4] are packed</p>
<p>acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]</p>
<p>x[4] and x[5] are packed</p>
<p>acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]</p>
<p>Read x[6] sample</p>
<p>x[5] and x[6] are packed</p>
<p>acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[srcBLen - 5] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[srcBLen - 5]</p>
<p>acc1 += x[5] * y[srcBLen - 5]</p>
<p>acc2 += x[6] * y[srcBLen - 5]</p>
<p>acc3 += x[7] * y[srcBLen - 5]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 4</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Reading two inputs of SrcA buffer and packing</p>
<p>Reading two inputs of SrcB buffer and packing</p>
<p>Perform the multiply-accumulates</p>
<p>Reading two inputs of SrcA buffer and packing</p>
<p>Reading two inputs of SrcB buffer and packing</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>srcBLen number of MACS should be performed</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1] sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2] .... sum += x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2] sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Reading two inputs, x[srcALen - srcBLen + 1] and x[srcALen - srcBLen + 2] of SrcA buffer and packing</p>
<p>Reading two inputs, y[srcBLen - 1] and y[srcBLen - 2] of SrcB buffer and packing</p>
<p>sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2]</p>
<p>Reading two inputs, x[srcALen - srcBLen + 3] and x[srcALen - srcBLen + 4] of SrcA buffer and packing</p>
<p>Reading two inputs, y[srcBLen - 3] and y[srcBLen - 4] of SrcB buffer and packing</p>
<p>sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3]</p>
<p>sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen-1] * y[srcBLen-1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter</p>
<p>set status as ARM_MATH_SUCCESS</p>
<p>Return to application </p>

<p>Definition at line <a class="el" href="arm__conv__partial__q7_8c_source.html#l00068">68</a> of file <a class="el" href="arm__conv__partial__q7_8c_source.html">arm_conv_partial_q7.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
