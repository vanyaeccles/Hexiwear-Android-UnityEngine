<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Finite Impulse Response (FIR) Lattice Filters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___f_i_r___lattice.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Finite Impulse Response (FIR) Lattice Filters<div class="ingroups"><a class="el" href="group__group_filters.html">Filtering Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae63a45a63a11a65f2eae8b8b1fe370a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#gae63a45a63a11a65f2eae8b8b1fe370a8">arm_fir_lattice_f32</a> (const <a class="el" href="structarm__fir__lattice__instance__f32.html">arm_fir_lattice_instance_f32</a> *S, float32_t *pSrc, float32_t *pDst, uint32_t blockSize)</td></tr>
<tr class="memdesc:gae63a45a63a11a65f2eae8b8b1fe370a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the floating-point FIR lattice filter.  <a href="#gae63a45a63a11a65f2eae8b8b1fe370a8">More...</a><br /></td></tr>
<tr class="separator:gae63a45a63a11a65f2eae8b8b1fe370a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86199a1590af2b8941c6532ee9d03229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#ga86199a1590af2b8941c6532ee9d03229">arm_fir_lattice_init_f32</a> (<a class="el" href="structarm__fir__lattice__instance__f32.html">arm_fir_lattice_instance_f32</a> *S, uint16_t numStages, float32_t *pCoeffs, float32_t *pState)</td></tr>
<tr class="memdesc:ga86199a1590af2b8941c6532ee9d03229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the floating-point FIR lattice filter.  <a href="#ga86199a1590af2b8941c6532ee9d03229">More...</a><br /></td></tr>
<tr class="separator:ga86199a1590af2b8941c6532ee9d03229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b22f30ce1cc19bf5a5d7c9fca154d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#ga1b22f30ce1cc19bf5a5d7c9fca154d72">arm_fir_lattice_init_q15</a> (<a class="el" href="structarm__fir__lattice__instance__q15.html">arm_fir_lattice_instance_q15</a> *S, uint16_t numStages, q15_t *pCoeffs, q15_t *pState)</td></tr>
<tr class="memdesc:ga1b22f30ce1cc19bf5a5d7c9fca154d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the Q15 FIR lattice filter.  <a href="#ga1b22f30ce1cc19bf5a5d7c9fca154d72">More...</a><br /></td></tr>
<tr class="separator:ga1b22f30ce1cc19bf5a5d7c9fca154d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05a17a0188bb851b58d19e572870a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#gac05a17a0188bb851b58d19e572870a54">arm_fir_lattice_init_q31</a> (<a class="el" href="structarm__fir__lattice__instance__q31.html">arm_fir_lattice_instance_q31</a> *S, uint16_t numStages, q31_t *pCoeffs, q31_t *pState)</td></tr>
<tr class="memdesc:gac05a17a0188bb851b58d19e572870a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the Q31 FIR lattice filter.  <a href="#gac05a17a0188bb851b58d19e572870a54">More...</a><br /></td></tr>
<tr class="separator:gac05a17a0188bb851b58d19e572870a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0ab07fd313b4d863070c3ddca51542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#gabb0ab07fd313b4d863070c3ddca51542">arm_fir_lattice_q15</a> (const <a class="el" href="structarm__fir__lattice__instance__q15.html">arm_fir_lattice_instance_q15</a> *S, q15_t *pSrc, q15_t *pDst, uint32_t blockSize)</td></tr>
<tr class="memdesc:gabb0ab07fd313b4d863070c3ddca51542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the Q15 FIR lattice filter.  <a href="#gabb0ab07fd313b4d863070c3ddca51542">More...</a><br /></td></tr>
<tr class="separator:gabb0ab07fd313b4d863070c3ddca51542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e36fd210e4a1a5dd333ce80dd6d9a88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_i_r___lattice.html#ga2e36fd210e4a1a5dd333ce80dd6d9a88">arm_fir_lattice_q31</a> (const <a class="el" href="structarm__fir__lattice__instance__q31.html">arm_fir_lattice_instance_q31</a> *S, q31_t *pSrc, q31_t *pDst, uint32_t blockSize)</td></tr>
<tr class="memdesc:ga2e36fd210e4a1a5dd333ce80dd6d9a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the Q31 FIR lattice filter.  <a href="#ga2e36fd210e4a1a5dd333ce80dd6d9a88">More...</a><br /></td></tr>
<tr class="separator:ga2e36fd210e4a1a5dd333ce80dd6d9a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This set of functions implements Finite Impulse Response (FIR) lattice filters for Q15, Q31 and floating-point data types. Lattice filters are used in a variety of adaptive filter applications. The filter structure is feedforward and the net impulse response is finite length. The functions operate on blocks of input and output data and each call to the function processes <code>blockSize</code> samples through the filter. <code>pSrc</code> and <code>pDst</code> point to input and output arrays containing <code>blockSize</code> values.</p>
<dl class="section user"><dt>Algorithm:</dt><dd><div class="image">
<img src="FIRLattice.gif" alt="FIRLattice.gif"/>
<div class="caption">
Finite Impulse Response Lattice filter</div></div>
 The following difference equation is implemented: <pre>
     f0[n] = g0[n] = x[n]
     fm[n] = fm-1[n] + km * gm-1[n-1] for m = 1, 2, ...M
     gm[n] = km * fm-1[n] + gm-1[n-1] for m = 1, 2, ...M
     y[n] = fM[n]
  </pre> </dd></dl>
<dl class="section user"><dt></dt><dd><code>pCoeffs</code> points to tha array of reflection coefficients of size <code>numStages</code>. Reflection Coefficients are stored in the following order. </dd></dl>
<dl class="section user"><dt></dt><dd><pre>
     {k1, k2, ..., kM}
  </pre> where M is number of stages </dd></dl>
<dl class="section user"><dt></dt><dd><code>pState</code> points to a state array of size <code>numStages</code>. The state variables (g values) hold previous inputs and are stored in the following order. <pre>
     {g0[n], g1[n], g2[n] ...gM-1[n]}
  </pre> The state variables are updated after each block of data is processed; the coefficients are untouched. </dd></dl>
<dl class="section user"><dt>Instance Structure</dt><dd>The coefficients and state variables for a filter are stored together in an instance data structure. A separate instance structure must be defined for each filter. Coefficient arrays may be shared among several instances while state variable arrays cannot be shared. There are separate instance structure declarations for each of the 3 supported data types.</dd></dl>
<dl class="section user"><dt>Initialization Functions</dt><dd>There is also an associated initialization function for each data type. The initialization function performs the following operations:<ul>
<li>Sets the values of the internal structure fields.</li>
<li>Zeros out the values in the state buffer. To do this manually without calling the init function, assign the follow subfields of the instance structure: numStages, pCoeffs, pState. Also set all of the values in pState to zero.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Use of the initialization function is optional. However, if the initialization function is used, then the instance structure cannot be placed into a const data section. To place an instance structure into a const data section, the instance structure must be manually initialized. Set the values in the state buffer to zeros and then manually initialize the instance structure as follows: <pre>
*arm_fir_lattice_instance_f32 S = {numStages, pState, pCoeffs};
*arm_fir_lattice_instance_q31 S = {numStages, pState, pCoeffs};
*arm_fir_lattice_instance_q15 S = {numStages, pState, pCoeffs};
  </pre> </dd></dl>
<dl class="section user"><dt></dt><dd>where <code>numStages</code> is the number of stages in the filter; <code>pState</code> is the address of the state buffer; <code>pCoeffs</code> is the address of the coefficient buffer. </dd></dl>
<dl class="section user"><dt>Fixed-Point Behavior</dt><dd>Care must be taken when using the fixed-point versions of the FIR Lattice filter functions. In particular, the overflow and saturation behavior of the accumulator used in each function must be considered. Refer to the function specific documentation below for usage guidelines. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae63a45a63a11a65f2eae8b8b1fe370a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__fir__lattice__instance__f32.html">arm_fir_lattice_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the floating-point FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the floating-point FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the block of input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the block of output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>number of samples to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>State pointer</p>
<p>Coefficient pointer</p>
<p>temporary state pointer</p>
<p>temporary coefficient pointer</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>temporary variables for first sample in loop unrolling</p>
<p>temporary variables for second sample in loop unrolling</p>
<p>temporary variables for third sample in loop unrolling</p>
<p>temporary variables for fourth sample in loop unrolling</p>
<p>Number of stages in the filter</p>
<p>temporary variables for counts</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Read two samples from input buffer</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>Read g0(n-1) from state</p>
<p>Process first sample for first tap</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>Process second sample for first tap</p>
<p>for sample 2 processing</p>
<p>Read next two samples from input buffer</p>
<p>f0(n+2) = x(n+2)</p>
<p>Copy only last input samples into the state buffer which will be used for next four samples processing</p>
<p>Process third sample for first tap</p>
<p>Process fourth sample for first tap</p>
<p>Update of f values for next coefficient set processing</p>
<p>Loop unrolling. Process 4 taps at a time .</p>
<p>Loop over the number of taps. Unroll by a factor of 4. Repeat until we've computed numStages-3 coefficients.</p>
<p>Process 2nd, 3rd, 4th and 5th taps ... here</p>
<p>Read g1(n-1), g3(n-1) .... from state</p>
<p>save g1(n) in state buffer</p>
<p>Process first sample for 2nd, 6th .. tap</p>
<p>Sample processing for K2, K6....</p>
<p>f2(n) = f1(n) + K2 * g1(n-1)</p>
<p>Process second sample for 2nd, 6th .. tap</p>
<p>for sample 2 processing</p>
<p>Process third sample for 2nd, 6th .. tap</p>
<p>Process fourth sample for 2nd, 6th .. tap</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>Calculation of state values for next stage</p>
<p>Read g2(n-1), g4(n-1) .... from state</p>
<p>save g2(n) in state buffer</p>
<p>Sample processing for K3, K7....</p>
<p>Process first sample for 3rd, 7th .. tap</p>
<p>f3(n) = f2(n) + K3 * g2(n-1)</p>
<p>Process second sample for 3rd, 7th .. tap</p>
<p>Process third sample for 3rd, 7th .. tap</p>
<p>Process fourth sample for 3rd, 7th .. tap</p>
<p>Calculation of state values for next stage</p>
<p>g3(n) = f2(n) * K3 + g2(n-1)</p>
<p>Read g1(n-1), g3(n-1) .... from state</p>
<p>save g3(n) in state buffer</p>
<p>Sample processing for K4, K8....</p>
<p>Process first sample for 4th, 8th .. tap</p>
<p>f4(n) = f3(n) + K4 * g3(n-1)</p>
<p>Process second sample for 4th, 8th .. tap</p>
<p>for sample 2 processing</p>
<p>Process third sample for 4th, 8th .. tap</p>
<p>Process fourth sample for 4th, 8th .. tap</p>
<p>g4(n) = f3(n) * K4 + g3(n-1)</p>
<p>Calculation of state values for next stage</p>
<p>Read g2(n-1), g4(n-1) .... from state</p>
<p>save g4(n) in state buffer</p>
<p>Sample processing for K5, K9....</p>
<p>Process first sample for 5th, 9th .. tap</p>
<p>f5(n) = f4(n) + K5 * g4(n-1)</p>
<p>Process second sample for 5th, 9th .. tap</p>
<p>Process third sample for 5th, 9th .. tap</p>
<p>Process fourth sample for 5th, 9th .. tap</p>
<p>Calculation of state values for next stage</p>
<p>g5(n) = f4(n) * K5 + g4(n-1)</p>
<p>If the (filter length -1) is not a multiple of 4, compute the remaining filter taps</p>
<p>save g value in state buffer</p>
<p>Process four samples for last three taps here</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>Update of f values for next coefficient set processing</p>
<p>The results in the 4 accumulators, store in the destination buffer.</p>
<p>y(n) = fN(n)</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>read g2(n) from state buffer</p>
<p>for sample 1 processing</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>save g1(n) in state buffer</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>stage loop</p>
<p>read g2(n) from state buffer</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K2, K3....</p>
<p>f2(n) = f1(n) + K2 * g1(n-1)</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>y(n) = fN(n) </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__f32_8c_source.html#l00131">131</a> of file <a class="el" href="arm__fir__lattice__f32_8c_source.html">arm_fir_lattice_f32.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l03745">arm_fir_lattice_instance_f32::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03747">arm_fir_lattice_instance_f32::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03746">arm_fir_lattice_instance_f32::pState</a>.</p>

</div>
</div>
<a class="anchor" id="ga86199a1590af2b8941c6532ee9d03229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_init_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__fir__lattice__instance__f32.html">arm_fir_lattice_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numStages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the floating-point FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the floating-point FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numStages</td><td>number of filter stages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pCoeffs</td><td>points to the coefficient buffer. The array is of length numStages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to the state buffer. The array is of length numStages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Assign filter taps</p>
<p>Assign coefficient pointer</p>
<p>Clear state buffer and size is always numStages</p>
<p>Assign state pointer </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__init__f32_8c_source.html#l00061">61</a> of file <a class="el" href="arm__fir__lattice__init__f32_8c_source.html">arm_fir_lattice_init_f32.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l03745">arm_fir_lattice_instance_f32::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03747">arm_fir_lattice_instance_f32::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03746">arm_fir_lattice_instance_f32::pState</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b22f30ce1cc19bf5a5d7c9fca154d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_init_q15 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__fir__lattice__instance__q15.html">arm_fir_lattice_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numStages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the Q15 FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q15 FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numStages</td><td>number of filter stages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pCoeffs</td><td>points to the coefficient buffer. The array is of length numStages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to the state buffer. The array is of length numStages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Assign filter taps</p>
<p>Assign coefficient pointer</p>
<p>Clear state buffer and size is always numStages</p>
<p>Assign state pointer </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__init__q15_8c_source.html#l00061">61</a> of file <a class="el" href="arm__fir__lattice__init__q15_8c_source.html">arm_fir_lattice_init_q15.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l03725">arm_fir_lattice_instance_q15::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03727">arm_fir_lattice_instance_q15::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03726">arm_fir_lattice_instance_q15::pState</a>.</p>

</div>
</div>
<a class="anchor" id="gac05a17a0188bb851b58d19e572870a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_init_q31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__fir__lattice__instance__q31.html">arm_fir_lattice_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numStages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the Q31 FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q31 FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numStages</td><td>number of filter stages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pCoeffs</td><td>points to the coefficient buffer. The array is of length numStages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to the state buffer. The array is of length numStages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Assign filter taps</p>
<p>Assign coefficient pointer</p>
<p>Clear state buffer and size is always numStages</p>
<p>Assign state pointer </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__init__q31_8c_source.html#l00061">61</a> of file <a class="el" href="arm__fir__lattice__init__q31_8c_source.html">arm_fir_lattice_init_q31.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l03735">arm_fir_lattice_instance_q31::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03737">arm_fir_lattice_instance_q31::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03736">arm_fir_lattice_instance_q31::pState</a>.</p>

</div>
</div>
<a class="anchor" id="gabb0ab07fd313b4d863070c3ddca51542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__fir__lattice__instance__q15.html">arm_fir_lattice_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the Q15 FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q15 FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the block of input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the block of output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>number of samples to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>State pointer</p>
<p>Coefficient pointer</p>
<p>temporary state pointer</p>
<p>temporary coefficient pointer</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>temporary variables for first sample in loop unrolling</p>
<p>temporary variables for second sample in loop unrolling</p>
<p>temporary variables for third sample in loop unrolling</p>
<p>temporary variables for fourth sample in loop unrolling</p>
<p>Number of stages in the filter</p>
<p>temporary variables for counts</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Read two samples from input buffer</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>Read g0(n-1) from state</p>
<p>Process first sample for first tap</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>Process second sample for first tap</p>
<p>for sample 2 processing</p>
<p>Read next two samples from input buffer</p>
<p>f0(n+2) = x(n+2)</p>
<p>Copy only last input samples into the state buffer which is used for next four samples processing</p>
<p>Process third sample for first tap</p>
<p>Process fourth sample for first tap</p>
<p>Update of f values for next coefficient set processing</p>
<p>Loop unrolling. Process 4 taps at a time .</p>
<p>Loop over the number of taps. Unroll by a factor of 4. Repeat until we've computed numStages-3 coefficients.</p>
<p>Process 2nd, 3rd, 4th and 5th taps ... here</p>
<p>Read g1(n-1), g3(n-1) .... from state</p>
<p>save g1(n) in state buffer</p>
<p>Process first sample for 2nd, 6th .. tap</p>
<p>Sample processing for K2, K6....</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>Process second sample for 2nd, 6th .. tap</p>
<p>for sample 2 processing</p>
<p>Process third sample for 2nd, 6th .. tap</p>
<p>Process fourth sample for 2nd, 6th .. tap</p>
<p>fnext4 = fcurnt4 + (*pk) * gnext3;</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>Calculation of state values for next stage</p>
<p>Read g2(n-1), g4(n-1) .... from state</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K3, K7....</p>
<p>Process first sample for 3rd, 7th .. tap</p>
<p>f3(n) = f2(n) + K3 * g2(n-1)</p>
<p>Process second sample for 3rd, 7th .. tap</p>
<p>Process third sample for 3rd, 7th .. tap</p>
<p>Process fourth sample for 3rd, 7th .. tap</p>
<p>Calculation of state values for next stage</p>
<p>g3(n) = f2(n) * K3 + g2(n-1)</p>
<p>Read g1(n-1), g3(n-1) .... from state</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K4, K8....</p>
<p>Process first sample for 4th, 8th .. tap</p>
<p>f4(n) = f3(n) + K4 * g3(n-1)</p>
<p>Process second sample for 4th, 8th .. tap</p>
<p>for sample 2 processing</p>
<p>Process third sample for 4th, 8th .. tap</p>
<p>Process fourth sample for 4th, 8th .. tap</p>
<p>g4(n) = f3(n) * K4 + g3(n-1)</p>
<p>Calculation of state values for next stage</p>
<p>Read g2(n-1), g4(n-1) .... from state</p>
<p>save g4(n) in state buffer</p>
<p>Sample processing for K5, K9....</p>
<p>Process first sample for 5th, 9th .. tap</p>
<p>f5(n) = f4(n) + K5 * g4(n-1)</p>
<p>Process second sample for 5th, 9th .. tap</p>
<p>Process third sample for 5th, 9th .. tap</p>
<p>Process fourth sample for 5th, 9th .. tap</p>
<p>Calculation of state values for next stage</p>
<p>g5(n) = f4(n) * K5 + g4(n-1)</p>
<p>If the (filter length -1) is not a multiple of 4, compute the remaining filter taps</p>
<p>save g value in state buffer</p>
<p>Process four samples for last three taps here</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>Update of f values for next coefficient set processing</p>
<p>The results in the 4 accumulators, store in the destination buffer.</p>
<p>y(n) = fN(n)</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>read g2(n) from state buffer</p>
<p>for sample 1 processing</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>save g1(n) in state buffer</p>
<p>f1(n) is saved in fcurnt1 for next stage processing</p>
<p>stage loop</p>
<p>read g2(n) from state buffer</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K2, K3....</p>
<p>f2(n) = f1(n) + K2 * g1(n-1)</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>f1(n) is saved in fcurnt1 for next stage processing</p>
<p>y(n) = fN(n) </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__q15_8c_source.html#l00062">62</a> of file <a class="el" href="arm__fir__lattice__q15_8c_source.html">arm_fir_lattice_q15.c</a>.</p>

<p>References <a class="el" href="arm__math_8h_source.html#l03725">arm_fir_lattice_instance_q15::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03727">arm_fir_lattice_instance_q15::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03726">arm_fir_lattice_instance_q15::pState</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e36fd210e4a1a5dd333ce80dd6d9a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_fir_lattice_q31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__fir__lattice__instance__q31.html">arm_fir_lattice_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the Q31 FIR lattice filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q31 FIR lattice structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the block of input data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the block of output data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>number of samples to process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b> In order to avoid overflows the input signal must be scaled down by 2*log2(numStages) bits.Run the below code for Cortex-M4 and Cortex-M3 </p>
<p>State pointer</p>
<p>Coefficient pointer</p>
<p>temporary state pointer</p>
<p>temporary coefficient pointer</p>
<p>temporary variables for first sample in loop unrolling</p>
<p>temporary variables for second sample in loop unrolling</p>
<p>Length of the filter</p>
<p>temporary variables for counts</p>
<p>First part of the processing with loop unrolling. Compute 2 outputs at a time. a second loop below computes the remaining 1 sample.</p>
<p>f0(n) = x(n)</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>read g0(n - 1) from state buffer</p>
<p>Read the reflection coefficient</p>
<p>for sample 1 processing</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>for sample 1 processing</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>save g1(n) in state buffer</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>stage loop</p>
<p>Read the reflection coefficient</p>
<p>read g2(n) from state buffer</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K2, K3....</p>
<p>f2(n) = f1(n) + K2 * g1(n-1)</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>y(n) = fN(n)</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>f0(n) = x(n)</p>
<p>Initialize coeff pointer</p>
<p>Initialize state pointer</p>
<p>read g0(n - 1) from state buffer</p>
<p>Read the reflection coefficient</p>
<p>for sample 1 processing</p>
<p>f1(n) = f0(n) + K1 * g0(n-1)</p>
<p>g1(n) = f0(n) * K1 + g0(n-1)</p>
<p>save g1(n) in state buffer</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>stage loop</p>
<p>Read the reflection coefficient</p>
<p>read g2(n) from state buffer</p>
<p>save g1(n) in state buffer</p>
<p>Sample processing for K2, K3....</p>
<p>f2(n) = f1(n) + K2 * g1(n-1)</p>
<p>g2(n) = f1(n) * K2 + g1(n-1)</p>
<p>f1(n) is saved in fcurr1 for next stage processing</p>
<p>y(n) = fN(n) </p>

<p>Definition at line <a class="el" href="arm__fir__lattice__q31_8c_source.html#l00070">70</a> of file <a class="el" href="arm__fir__lattice__q31_8c_source.html">arm_fir_lattice_q31.c</a>.</p>

<p>References <a class="el" href="arm__fir__lattice__q31_8c_source.html#l00070">arm_fir_lattice_q31()</a>, <a class="el" href="arm__math_8h_source.html#l03735">arm_fir_lattice_instance_q31::numStages</a>, <a class="el" href="arm__math_8h_source.html#l03737">arm_fir_lattice_instance_q31::pCoeffs</a>, and <a class="el" href="arm__math_8h_source.html#l03736">arm_fir_lattice_instance_q31::pState</a>.</p>

<p>Referenced by <a class="el" href="arm__fir__lattice__q31_8c_source.html#l00070">arm_fir_lattice_q31()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
