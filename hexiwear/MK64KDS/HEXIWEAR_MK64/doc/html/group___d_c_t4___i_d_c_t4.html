<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: DCT Type IV Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___d_c_t4___i_d_c_t4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DCT Type IV Functions<div class="ingroups"><a class="el" href="group__group_transforms.html">Transform Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafd538d68886848bc090ec2b0d364cc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#gafd538d68886848bc090ec2b0d364cc81">arm_dct4_f32</a> (const <a class="el" href="structarm__dct4__instance__f32.html">arm_dct4_instance_f32</a> *S, float32_t *pState, float32_t *pInlineBuffer)</td></tr>
<tr class="memdesc:gafd538d68886848bc090ec2b0d364cc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the floating-point DCT4/IDCT4.  <a href="#gafd538d68886848bc090ec2b0d364cc81">More...</a><br /></td></tr>
<tr class="separator:gafd538d68886848bc090ec2b0d364cc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab094ad3bc6fa1b84e8b12a24e1850a06"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#gab094ad3bc6fa1b84e8b12a24e1850a06">arm_dct4_init_f32</a> (<a class="el" href="structarm__dct4__instance__f32.html">arm_dct4_instance_f32</a> *S, <a class="el" href="structarm__rfft__instance__f32.html">arm_rfft_instance_f32</a> *S_RFFT, <a class="el" href="structarm__cfft__radix4__instance__f32.html">arm_cfft_radix4_instance_f32</a> *S_CFFT, uint16_t N, uint16_t Nby2, float32_t normalize)</td></tr>
<tr class="memdesc:gab094ad3bc6fa1b84e8b12a24e1850a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the floating-point DCT4/IDCT4.  <a href="#gab094ad3bc6fa1b84e8b12a24e1850a06">More...</a><br /></td></tr>
<tr class="separator:gab094ad3bc6fa1b84e8b12a24e1850a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966fd1b66a80873964533703ab5dc054"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#ga966fd1b66a80873964533703ab5dc054">arm_dct4_init_q15</a> (<a class="el" href="structarm__dct4__instance__q15.html">arm_dct4_instance_q15</a> *S, <a class="el" href="structarm__rfft__instance__q15.html">arm_rfft_instance_q15</a> *S_RFFT, <a class="el" href="structarm__cfft__radix4__instance__q15.html">arm_cfft_radix4_instance_q15</a> *S_CFFT, uint16_t N, uint16_t Nby2, q15_t normalize)</td></tr>
<tr class="memdesc:ga966fd1b66a80873964533703ab5dc054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the Q15 DCT4/IDCT4.  <a href="#ga966fd1b66a80873964533703ab5dc054">More...</a><br /></td></tr>
<tr class="separator:ga966fd1b66a80873964533703ab5dc054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631bb59c7c97c814ff7147ecba6a716a"><td class="memItemLeft" align="right" valign="top">arm_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#ga631bb59c7c97c814ff7147ecba6a716a">arm_dct4_init_q31</a> (<a class="el" href="structarm__dct4__instance__q31.html">arm_dct4_instance_q31</a> *S, <a class="el" href="structarm__rfft__instance__q31.html">arm_rfft_instance_q31</a> *S_RFFT, <a class="el" href="structarm__cfft__radix4__instance__q31.html">arm_cfft_radix4_instance_q31</a> *S_CFFT, uint16_t N, uint16_t Nby2, q31_t normalize)</td></tr>
<tr class="memdesc:ga631bb59c7c97c814ff7147ecba6a716a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the Q31 DCT4/IDCT4.  <a href="#ga631bb59c7c97c814ff7147ecba6a716a">More...</a><br /></td></tr>
<tr class="separator:ga631bb59c7c97c814ff7147ecba6a716a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114cb9635059f678df291fcc887aaf2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#ga114cb9635059f678df291fcc887aaf2b">arm_dct4_q15</a> (const <a class="el" href="structarm__dct4__instance__q15.html">arm_dct4_instance_q15</a> *S, q15_t *pState, q15_t *pInlineBuffer)</td></tr>
<tr class="memdesc:ga114cb9635059f678df291fcc887aaf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the Q15 DCT4/IDCT4.  <a href="#ga114cb9635059f678df291fcc887aaf2b">More...</a><br /></td></tr>
<tr class="separator:ga114cb9635059f678df291fcc887aaf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04d0baab6ed081d8e8afe02538eb80b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_c_t4___i_d_c_t4.html#gad04d0baab6ed081d8e8afe02538eb80b">arm_dct4_q31</a> (const <a class="el" href="structarm__dct4__instance__q31.html">arm_dct4_instance_q31</a> *S, q31_t *pState, q31_t *pInlineBuffer)</td></tr>
<tr class="memdesc:gad04d0baab6ed081d8e8afe02538eb80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processing function for the Q31 DCT4/IDCT4.  <a href="#gad04d0baab6ed081d8e8afe02538eb80b">More...</a><br /></td></tr>
<tr class="separator:gad04d0baab6ed081d8e8afe02538eb80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Representation of signals by minimum number of values is important for storage and transmission. The possibility of large discontinuity between the beginning and end of a period of a signal in DFT can be avoided by extending the signal so that it is even-symmetric. Discrete Cosine Transform (DCT) is constructed such that its energy is heavily concentrated in the lower part of the spectrum and is very widely used in signal and image coding applications. The family of DCTs (DCT type- 1,2,3,4) is the outcome of different combinations of homogeneous boundary conditions. DCT has an excellent energy-packing capability, hence has many applications and in data compression in particular.</p>
<p>DCT is essentially the Discrete Fourier Transform(DFT) of an even-extended real signal. Reordering of the input data makes the computation of DCT just a problem of computing the DFT of a real signal with a few additional operations. This approach provides regular, simple, and very efficient DCT algorithms for practical hardware and software implementations.</p>
<p>DCT type-II can be implemented using Fast fourier transform (FFT) internally, as the transform is applied on real values, Real FFT can be used. DCT4 is implemented using DCT2 as their implementations are similar except with some added pre-processing and post-processing. DCT2 implementation can be described in the following steps:</p><ul>
<li>Re-ordering input</li>
<li>Calculating Real FFT</li>
<li>Multiplication of weights and Real FFT output and getting real part from the product.</li>
</ul>
<p>This process is explained by the block diagram below: </p><div class="image">
<img src="DCT4.gif" alt="DCT4.gif"/>
<div class="caption">
Discrete Cosine Transform - type-IV</div></div>
 <dl class="section user"><dt>Algorithm:</dt><dd>The N-point type-IV DCT is defined as a real, linear transformation by the formula: <div class="image">
<img src="DCT4Equation.gif" alt="DCT4Equation.gif"/>
</div>
 where <code>k = 0,1,2,.....N-1</code> </dd></dl>
<dl class="section user"><dt></dt><dd>Its inverse is defined as follows: <div class="image">
<img src="IDCT4Equation.gif" alt="IDCT4Equation.gif"/>
</div>
 where <code>n = 0,1,2,.....N-1</code> </dd></dl>
<dl class="section user"><dt></dt><dd>The DCT4 matrices become involutory (i.e. they are self-inverse) by multiplying with an overall scale factor of sqrt(2/N). The symmetry of the transform matrix indicates that the fast algorithms for the forward and inverse transform computation are identical. Note that the implementation of Inverse DCT4 and DCT4 is same, hence same process function can be used for both.</dd></dl>
<dl class="section user"><dt>Lengths supported by the transform:</dt><dd>As DCT4 internally uses Real FFT, it supports all the lengths supported by <a class="el" href="group___real_f_f_t.html#ga3df1766d230532bc068fc4ed69d0fcdc" title="Processing function for the floating-point RFFT/RIFFT. ">arm_rfft_f32()</a>. The library provides separate functions for Q15, Q31, and floating-point data types. </dd></dl>
<dl class="section user"><dt>Instance Structure</dt><dd>The instances for Real FFT and FFT, cosine values table and twiddle factor table are stored in an instance data structure. A separate instance structure must be defined for each transform. There are separate instance structure declarations for each of the 3 supported data types.</dd></dl>
<dl class="section user"><dt>Initialization Functions</dt><dd>There is also an associated initialization function for each data type. The initialization function performs the following operations:<ul>
<li>Sets the values of the internal structure fields.</li>
<li>Initializes Real FFT as its process function is used internally in DCT4, by calling <a class="el" href="group___real_f_f_t.html#ga10717ee326bf50832ef1c25b85a23068" title="Initialization function for the floating-point RFFT/RIFFT. ">arm_rfft_init_f32()</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Use of the initialization function is optional. However, if the initialization function is used, then the instance structure cannot be placed into a const data section. To place an instance structure into a const data section, the instance structure must be manually initialized. Manually initialize the instance structure as follows: <pre>
*arm_dct4_instance_f32 S = {N, Nby2, normalize, pTwiddle, pCosFactor, pRfft, pCfft};
*arm_dct4_instance_q31 S = {N, Nby2, normalize, pTwiddle, pCosFactor, pRfft, pCfft};
*arm_dct4_instance_q15 S = {N, Nby2, normalize, pTwiddle, pCosFactor, pRfft, pCfft};
  </pre> where <code>N</code> is the length of the DCT4; <code>Nby2</code> is half of the length of the DCT4; <code>normalize</code> is normalizing factor used and is equal to <code>sqrt(2/N)</code>; <code>pTwiddle</code> points to the twiddle factor table; <code>pCosFactor</code> points to the cosFactor table; <code>pRfft</code> points to the real FFT instance; <code>pCfft</code> points to the complex FFT instance; The CFFT and RFFT structures also needs to be initialized, refer to <a class="el" href="group___complex_f_f_t.html#ga521f670cd9c571bc61aff9bec89f4c26" title="Processing function for the floating-point Radix-4 CFFT/CIFFT. ">arm_cfft_radix4_f32()</a> and <a class="el" href="group___real_f_f_t.html#ga3df1766d230532bc068fc4ed69d0fcdc" title="Processing function for the floating-point RFFT/RIFFT. ">arm_rfft_f32()</a> respectively for details regarding static initialization.</dd></dl>
<dl class="section user"><dt>Fixed-Point Behavior</dt><dd>Care must be taken when using the fixed-point versions of the DCT4 transform functions. In particular, the overflow and saturation behavior of the accumulator used in each function must be considered. Refer to the function specific documentation below for usage guidelines. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafd538d68886848bc090ec2b0d364cc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_dct4_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__dct4__instance__f32.html">arm_dct4_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pInlineBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the floating-point DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the floating-point DCT4/IDCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to state buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*pInlineBuffer</td><td>points to the in-place input and output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Loop counter</p>
<p>Pointer to the Weights table</p>
<p>Pointer to the cos factors table</p>
<p>Temporary pointers for input buffer and pState buffer</p>
<p>Temporary variable</p>
<p>DCT4 computation involves DCT2 (which is calculated using RFFT) along with some pre-processing and post-processing. Computational procedure is explained as follows: (a) Pre-processing involves multiplying input with cos factor, r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n)) where, r(n) &ndash; output of preprocessing u(n) &ndash; input to preprocessing(actual Source buffer) (b) Calculation of DCT2 using FFT is divided into three steps: Step1: Re-ordering of even and odd elements of input. Step2: Calculating FFT of the re-ordered input. Step3: Taking the real part of the product of FFT output and weights. (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation: Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) where, Y4 &ndash; DCT4 output, Y2 &ndash; DCT2 output (d) Multiplying the output with the normalizing factor sqrt(2/N).</p>
<p>Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n))</p>
<p>pS1 initialized to pState</p>
<p>pS2 initialized to pState+N-1, so that it points to the end of the state buffer</p>
<p>pbuff initialized to input buffer</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Initializing the loop counter to N/2 &gt;&gt; 2 for loop unrolling by 4</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Re-ordering of even and odd elements</p>
<p>pState[i] = pInlineBuffer[2*i]</p>
<p>pState[N-i-1] = pInlineBuffer[2*i+1]</p>
<p>Decrement the loop counter</p>
<p>pbuff initialized to input buffer</p>
<p>pS1 initialized to pState</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Writing the re-ordered output back to inplace input buffer</p>
<p>Decrement the loop counter</p>
<p>pInlineBuffer is real input of length N , pState is the complex output of length 2N</p>
<p>DCT-IV can be obtained from DCT-II by the equation, Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) Hence, Y4(0) = Y2(0)/2</p>
<p>Getting only real part from the output and Converting to DCT-IV</p>
<p>Initializing the loop counter to N &gt;&gt; 2 for loop unrolling by 4</p>
<p>pbuff initialized to input buffer.</p>
<p>pS1 initialized to pState</p>
<p>Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2</p>
<p>input buffer acts as inplace, so output values are stored in the input itself.</p>
<p>pState pointer is incremented twice as the real values are located alternatively in the array</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>pbuff initialized to the pInlineBuffer(now contains the output values)</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Multiplying pInlineBuffer with the normalizing factor sqrt(2/N)</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__dct4__f32_8c_source.html#l00137">137</a> of file <a class="el" href="arm__dct4__f32_8c_source.html">arm_dct4_f32.c</a>.</p>

<p>References <a class="el" href="arm__mult__f32_8c_source.html#l00073">arm_mult_f32()</a>, <a class="el" href="arm__scale__f32_8c_source.html#l00089">arm_scale_f32()</a>, <a class="el" href="arm__math_8h_source.html#l02256">arm_dct4_instance_f32::N</a>, <a class="el" href="arm__math_8h_source.html#l02257">arm_dct4_instance_f32::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02260">arm_dct4_instance_f32::pCosFactor</a>, and <a class="el" href="arm__math_8h_source.html#l02259">arm_dct4_instance_f32::pTwiddle</a>.</p>

</div>
</div>
<a class="anchor" id="gab094ad3bc6fa1b84e8b12a24e1850a06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_dct4_init_f32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__dct4__instance__f32.html">arm_dct4_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__rfft__instance__f32.html">arm_rfft_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S_RFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__cfft__radix4__instance__f32.html">arm_cfft_radix4_instance_f32</a> *&#160;</td>
          <td class="paramname"><em>S_CFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Nby2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the floating-point DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*S</td><td>points to an instance of floating-point DCT4/IDCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_RFFT</td><td>points to an instance of floating-point RFFT/RIFFT structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_CFFT</td><td>points to an instance of floating-point CFFT/CIFFT structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nby2</td><td>half of the length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>normalizing factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length. </dd></dl>
<dl class="section user"><dt>Normalizing factor:</dt><dd>The normalizing factor is <code>sqrt(2/N)</code>, which depends on the size of transform <code>N</code>. Floating-point normalizing factors are mentioned in the table below for different DCT sizes: <div class="image">
<img src="dct4NormalizingF32Table.gif" alt="dct4NormalizingF32Table.gif"/>
</div>
 </dd></dl>
<p>Initializing the pointer array with the weight table base addresses of different lengths</p>
<p>Initializing the pointer array with the cos factor table base addresses of different lengths</p>
<p>Initialize the DCT4 length</p>
<p>Initialize the half of DCT4 length</p>
<p>Initialize the DCT4 Normalizing factor</p>
<p>Initialize Real FFT Instance</p>
<p>Initialize Complex FFT Instance</p>
<p>Initialize the table modifier values</p>
<p>Initialize the RFFT/RIFFT</p>
<p>return the status of DCT4 Init function </p>

<p>Definition at line <a class="el" href="arm__dct4__init__f32_8c_source.html#l16449">16449</a> of file <a class="el" href="arm__dct4__init__f32_8c_source.html">arm_dct4_init_f32.c</a>.</p>

<p>References <a class="el" href="arm__rfft__init__f32_8c_source.html#l08304">arm_rfft_init_f32()</a>, <a class="el" href="arm__math_8h_source.html#l02256">arm_dct4_instance_f32::N</a>, <a class="el" href="arm__math_8h_source.html#l02257">arm_dct4_instance_f32::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02258">arm_dct4_instance_f32::normalize</a>, <a class="el" href="arm__math_8h_source.html#l02262">arm_dct4_instance_f32::pCfft</a>, <a class="el" href="arm__math_8h_source.html#l02260">arm_dct4_instance_f32::pCosFactor</a>, <a class="el" href="arm__math_8h_source.html#l02261">arm_dct4_instance_f32::pRfft</a>, and <a class="el" href="arm__math_8h_source.html#l02259">arm_dct4_instance_f32::pTwiddle</a>.</p>

</div>
</div>
<a class="anchor" id="ga966fd1b66a80873964533703ab5dc054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_dct4_init_q15 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__dct4__instance__q15.html">arm_dct4_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__rfft__instance__q15.html">arm_rfft_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S_RFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__cfft__radix4__instance__q15.html">arm_cfft_radix4_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S_CFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Nby2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the Q15 DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*S</td><td>points to an instance of Q15 DCT4/IDCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_RFFT</td><td>points to an instance of Q15 RFFT/RIFFT structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_CFFT</td><td>points to an instance of Q15 CFFT/CIFFT structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nby2</td><td>half of the length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>normalizing factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length. </dd></dl>
<dl class="section user"><dt>Normalizing factor:</dt><dd>The normalizing factor is <code>sqrt(2/N)</code>, which depends on the size of transform <code>N</code>. Normalizing factors in 1.15 format are mentioned in the table below for different DCT sizes: <div class="image">
<img src="dct4NormalizingQ15Table.gif" alt="dct4NormalizingQ15Table.gif"/>
</div>
 </dd></dl>
<p>Initializing the pointer array with the weight table base addresses of different lengths</p>
<p>Initializing the pointer array with the cos factor table base addresses of different lengths</p>
<p>Initialize the DCT4 length</p>
<p>Initialize the half of DCT4 length</p>
<p>Initialize the DCT4 Normalizing factor</p>
<p>Initialize Real FFT Instance</p>
<p>Initialize Complex FFT Instance</p>
<p>Initialize the table modifier values</p>
<p>Initialize the RFFT/RIFFT</p>
<p>return the status of DCT4 Init function </p>

<p>Definition at line <a class="el" href="arm__dct4__init__q15_8c_source.html#l04215">4215</a> of file <a class="el" href="arm__dct4__init__q15_8c_source.html">arm_dct4_init_q15.c</a>.</p>

<p>References <a class="el" href="arm__rfft__init__q15_8c_source.html#l02160">arm_rfft_init_q15()</a>, <a class="el" href="arm__math_8h_source.html#l02348">arm_dct4_instance_q15::N</a>, <a class="el" href="arm__math_8h_source.html#l02349">arm_dct4_instance_q15::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02350">arm_dct4_instance_q15::normalize</a>, <a class="el" href="arm__math_8h_source.html#l02354">arm_dct4_instance_q15::pCfft</a>, <a class="el" href="arm__math_8h_source.html#l02352">arm_dct4_instance_q15::pCosFactor</a>, <a class="el" href="arm__math_8h_source.html#l02353">arm_dct4_instance_q15::pRfft</a>, and <a class="el" href="arm__math_8h_source.html#l02351">arm_dct4_instance_q15::pTwiddle</a>.</p>

</div>
</div>
<a class="anchor" id="ga631bb59c7c97c814ff7147ecba6a716a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm_status arm_dct4_init_q31 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarm__dct4__instance__q31.html">arm_dct4_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__rfft__instance__q31.html">arm_rfft_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S_RFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarm__cfft__radix4__instance__q31.html">arm_cfft_radix4_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S_CFFT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Nby2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the Q31 DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*S</td><td>points to an instance of Q31 DCT4/IDCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_RFFT</td><td>points to an instance of Q31 RFFT/RIFFT structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*S_CFFT</td><td>points to an instance of Q31 CFFT/CIFFT structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nby2</td><td>half of the length of the DCT4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>normalizing factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length. </dd></dl>
<dl class="section user"><dt>Normalizing factor:</dt><dd>The normalizing factor is <code>sqrt(2/N)</code>, which depends on the size of transform <code>N</code>. Normalizing factors in 1.31 format are mentioned in the table below for different DCT sizes: <div class="image">
<img src="dct4NormalizingQ31Table.gif" alt="dct4NormalizingQ31Table.gif"/>
</div>
 </dd></dl>
<p>Initializing the pointer array with the weight table base addresses of different lengths</p>
<p>Initializing the pointer array with the cos factor table base addresses of different lengths</p>
<p>Initialize the DCT4 length</p>
<p>Initialize the half of DCT4 length</p>
<p>Initialize the DCT4 Normalizing factor</p>
<p>Initialize Real FFT Instance</p>
<p>Initialize Complex FFT Instance</p>
<p>Initialize the table modifier values</p>
<p>Initialize the RFFT/RIFFT Function</p>
<p>return the status of DCT4 Init function </p>

<p>Definition at line <a class="el" href="arm__dct4__init__q31_8c_source.html#l08295">8295</a> of file <a class="el" href="arm__dct4__init__q31_8c_source.html">arm_dct4_init_q31.c</a>.</p>

<p>References <a class="el" href="arm__rfft__init__q31_8c_source.html#l04210">arm_rfft_init_q31()</a>, <a class="el" href="arm__math_8h_source.html#l02302">arm_dct4_instance_q31::N</a>, <a class="el" href="arm__math_8h_source.html#l02303">arm_dct4_instance_q31::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02304">arm_dct4_instance_q31::normalize</a>, <a class="el" href="arm__math_8h_source.html#l02308">arm_dct4_instance_q31::pCfft</a>, <a class="el" href="arm__math_8h_source.html#l02306">arm_dct4_instance_q31::pCosFactor</a>, <a class="el" href="arm__math_8h_source.html#l02307">arm_dct4_instance_q31::pRfft</a>, and <a class="el" href="arm__math_8h_source.html#l02305">arm_dct4_instance_q31::pTwiddle</a>.</p>

</div>
</div>
<a class="anchor" id="ga114cb9635059f678df291fcc887aaf2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_dct4_q15 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__dct4__instance__q15.html">arm_dct4_instance_q15</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pInlineBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the Q15 DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q15 DCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to state buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*pInlineBuffer</td><td>points to the in-place input and output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<dl class="section user"><dt>Input an output formats:</dt><dd>Internally inputs are downscaled in the RFFT process function to avoid overflows. Number of bits downscaled, depends on the size of the transform. The input and output formats for different DCT sizes and number of bits to upscale are mentioned in the table below:</dd></dl>
<div class="image">
<img src="dct4FormatsQ15Table.gif" alt="dct4FormatsQ15Table.gif"/>
</div>
 <p>Loop counter</p>
<p>Pointer to the Weights table</p>
<p>Pointer to the cos factors table</p>
<p>Temporary pointers for input buffer and pState buffer</p>
<p>Temporary variable</p>
<p>DCT4 computation involves DCT2 (which is calculated using RFFT) along with some pre-processing and post-processing. Computational procedure is explained as follows: (a) Pre-processing involves multiplying input with cos factor, r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n)) where, r(n) &ndash; output of preprocessing u(n) &ndash; input to preprocessing(actual Source buffer) (b) Calculation of DCT2 using FFT is divided into three steps: Step1: Re-ordering of even and odd elements of input. Step2: Calculating FFT of the re-ordered input. Step3: Taking the real part of the product of FFT output and weights. (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation: Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) where, Y4 &ndash; DCT4 output, Y2 &ndash; DCT2 output (d) Multiplying the output with the normalizing factor sqrt(2/N).</p>
<p>Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n))</p>
<p>pS1 initialized to pState</p>
<p>pS2 initialized to pState+N-1, so that it points to the end of the state buffer</p>
<p>pbuff initialized to input buffer</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Initializing the loop counter to N/2 &gt;&gt; 2 for loop unrolling by 4</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Re-ordering of even and odd elements</p>
<p>pState[i] = pInlineBuffer[2*i]</p>
<p>pState[N-i-1] = pInlineBuffer[2*i+1]</p>
<p>Decrement the loop counter</p>
<p>pbuff initialized to input buffer</p>
<p>pS1 initialized to pState</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Writing the re-ordered output back to inplace input buffer</p>
<p>Decrement the loop counter</p>
<p>pInlineBuffer is real input of length N , pState is the complex output of length 2N</p>
<p>The output of complex multiplication is in 3.13 format. Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.15 format by shifting left by 2 bits.</p>
<p>DCT-IV can be obtained from DCT-II by the equation, Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) Hence, Y4(0) = Y2(0)/2</p>
<p>Getting only real part from the output and Converting to DCT-IV</p>
<p>Initializing the loop counter to N &gt;&gt; 2 for loop unrolling by 4</p>
<p>pbuff initialized to input buffer.</p>
<p>pS1 initialized to pState</p>
<p>Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2</p>
<p>input buffer acts as inplace, so output values are stored in the input itself.</p>
<p>pState pointer is incremented twice as the real values are located alternatively in the array</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>pbuff initialized to the pInlineBuffer(now contains the output values)</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Multiplying pInlineBuffer with the normalizing factor sqrt(2/N)</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__dct4__q15_8c_source.html#l00063">63</a> of file <a class="el" href="arm__dct4__q15_8c_source.html">arm_dct4_q15.c</a>.</p>

<p>References <a class="el" href="arm__mult__q15_8c_source.html#l00067">arm_mult_q15()</a>, <a class="el" href="arm__shift__q15_8c_source.html#l00066">arm_shift_q15()</a>, <a class="el" href="arm__math_8h_source.html#l02348">arm_dct4_instance_q15::N</a>, <a class="el" href="arm__math_8h_source.html#l02349">arm_dct4_instance_q15::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02352">arm_dct4_instance_q15::pCosFactor</a>, and <a class="el" href="arm__math_8h_source.html#l02351">arm_dct4_instance_q15::pTwiddle</a>.</p>

</div>
</div>
<a class="anchor" id="gad04d0baab6ed081d8e8afe02538eb80b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_dct4_q31 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarm__dct4__instance__q31.html">arm_dct4_instance_q31</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pInlineBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processing function for the Q31 DCT4/IDCT4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*S</td><td>points to an instance of the Q31 DCT4 structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pState</td><td>points to state buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">*pInlineBuffer</td><td>points to the in-place input and output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="section user"><dt>Input an output formats:</dt><dd>Input samples need to be downscaled by 1 bit to avoid saturations in the Q31 DCT process, as the conversion from DCT2 to DCT4 involves one subtraction. Internally inputs are downscaled in the RFFT process function to avoid overflows. Number of bits downscaled, depends on the size of the transform. The input and output formats for different DCT sizes and number of bits to upscale are mentioned in the table below:</dd></dl>
<div class="image">
<img src="dct4FormatsQ31Table.gif" alt="dct4FormatsQ31Table.gif"/>
</div>
 <p>Loop counter</p>
<p>Pointer to the Weights table</p>
<p>Pointer to the cos factors table</p>
<p>Temporary pointers for input buffer and pState buffer</p>
<p>Temporary variable</p>
<p>DCT4 computation involves DCT2 (which is calculated using RFFT) along with some pre-processing and post-processing. Computational procedure is explained as follows: (a) Pre-processing involves multiplying input with cos factor, r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n)) where, r(n) &ndash; output of preprocessing u(n) &ndash; input to preprocessing(actual Source buffer) (b) Calculation of DCT2 using FFT is divided into three steps: Step1: Re-ordering of even and odd elements of input. Step2: Calculating FFT of the re-ordered input. Step3: Taking the real part of the product of FFT output and weights. (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation: Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) where, Y4 &ndash; DCT4 output, Y2 &ndash; DCT2 output (d) Multiplying the output with the normalizing factor sqrt(2/N).</p>
<p>Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n))</p>
<p>pS1 initialized to pState</p>
<p>pS2 initialized to pState+N-1, so that it points to the end of the state buffer</p>
<p>pbuff initialized to input buffer</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Initializing the loop counter to N/2 &gt;&gt; 2 for loop unrolling by 4</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Re-ordering of even and odd elements</p>
<p>pState[i] = pInlineBuffer[2*i]</p>
<p>pState[N-i-1] = pInlineBuffer[2*i+1]</p>
<p>Decrement the loop counter</p>
<p>pbuff initialized to input buffer</p>
<p>pS1 initialized to pState</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Writing the re-ordered output back to inplace input buffer</p>
<p>Decrement the loop counter</p>
<p>pInlineBuffer is real input of length N , pState is the complex output of length 2N</p>
<p>The output of complex multiplication is in 3.29 format. Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.31 format by shifting left by 2 bits.</p>
<p>DCT-IV can be obtained from DCT-II by the equation, Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0) Hence, Y4(0) = Y2(0)/2</p>
<p>Getting only real part from the output and Converting to DCT-IV</p>
<p>Initializing the loop counter to N &gt;&gt; 2 for loop unrolling by 4</p>
<p>pbuff initialized to input buffer.</p>
<p>pS1 initialized to pState</p>
<p>Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2</p>
<p>input buffer acts as inplace, so output values are stored in the input itself.</p>
<p>pState pointer is incremented twice as the real values are located alternatively in the array</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1)</p>
<p>pState pointer (pS1) is incremented twice as the real values are located alternatively in the array</p>
<p>points to the next real value</p>
<p>Decrement the loop counter</p>
<p>Initializing the loop counter to N/4 instead of N for loop unrolling</p>
<p>pbuff initialized to the pInlineBuffer(now contains the output values)</p>
<p>Processing with loop unrolling 4 times as N is always multiple of 4. Compute 4 outputs at a time</p>
<p>Multiplying pInlineBuffer with the normalizing factor sqrt(2/N)</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__dct4__q31_8c_source.html#l00064">64</a> of file <a class="el" href="arm__dct4__q31_8c_source.html">arm_dct4_q31.c</a>.</p>

<p>References <a class="el" href="arm__cmplx__mult__cmplx__q31_8c_source.html#l00067">arm_cmplx_mult_cmplx_q31()</a>, <a class="el" href="arm__mult__q31_8c_source.html#l00066">arm_mult_q31()</a>, <a class="el" href="arm__rfft__q31_8c_source.html#l00087">arm_rfft_q31()</a>, <a class="el" href="arm__shift__q31_8c_source.html#l00084">arm_shift_q31()</a>, <a class="el" href="arm__math_8h_source.html#l02302">arm_dct4_instance_q31::N</a>, <a class="el" href="arm__math_8h_source.html#l02303">arm_dct4_instance_q31::Nby2</a>, <a class="el" href="arm__math_8h_source.html#l02304">arm_dct4_instance_q31::normalize</a>, <a class="el" href="arm__math_8h_source.html#l02306">arm_dct4_instance_q31::pCosFactor</a>, <a class="el" href="arm__math_8h_source.html#l02307">arm_dct4_instance_q31::pRfft</a>, and <a class="el" href="arm__math_8h_source.html#l02305">arm_dct4_instance_q31::pTwiddle</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
