<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Correlation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___corr.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Correlation<div class="ingroups"><a class="el" href="group__group_filters.html">Filtering Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga22021e4222773f01e9960358a531cfb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga22021e4222773f01e9960358a531cfb8">arm_correlate_f32</a> (float32_t *pSrcA, uint32_t srcALen, float32_t *pSrcB, uint32_t srcBLen, float32_t *pDst)</td></tr>
<tr class="memdesc:ga22021e4222773f01e9960358a531cfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of floating-point sequences.  <a href="#ga22021e4222773f01e9960358a531cfb8">More...</a><br /></td></tr>
<tr class="separator:ga22021e4222773f01e9960358a531cfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a0236b17220e8e22a22b5bc1c53c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga40a0236b17220e8e22a22b5bc1c53c6b">arm_correlate_fast_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, q15_t *pScratch)</td></tr>
<tr class="memdesc:ga40a0236b17220e8e22a22b5bc1c53c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#ga40a0236b17220e8e22a22b5bc1c53c6b">More...</a><br /></td></tr>
<tr class="separator:ga40a0236b17220e8e22a22b5bc1c53c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8de3da44f58e86c2c86156276ca154f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#gac8de3da44f58e86c2c86156276ca154f">arm_correlate_fast_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst)</td></tr>
<tr class="memdesc:gac8de3da44f58e86c2c86156276ca154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#gac8de3da44f58e86c2c86156276ca154f">More...</a><br /></td></tr>
<tr class="separator:gac8de3da44f58e86c2c86156276ca154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabecd3d7b077dbbef43f93e9e037815ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#gabecd3d7b077dbbef43f93e9e037815ed">arm_correlate_fast_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst)</td></tr>
<tr class="memdesc:gabecd3d7b077dbbef43f93e9e037815ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="#gabecd3d7b077dbbef43f93e9e037815ed">More...</a><br /></td></tr>
<tr class="separator:gabecd3d7b077dbbef43f93e9e037815ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71c0ec70ec69edbc48563d9a5f68451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#gad71c0ec70ec69edbc48563d9a5f68451">arm_correlate_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, q15_t *pScratch)</td></tr>
<tr class="memdesc:gad71c0ec70ec69edbc48563d9a5f68451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q15 sequences.  <a href="#gad71c0ec70ec69edbc48563d9a5f68451">More...</a><br /></td></tr>
<tr class="separator:gad71c0ec70ec69edbc48563d9a5f68451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746e8857cafe33ec5d6780729c18c311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga746e8857cafe33ec5d6780729c18c311">arm_correlate_opt_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:ga746e8857cafe33ec5d6780729c18c311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q7 sequences.  <a href="#ga746e8857cafe33ec5d6780729c18c311">More...</a><br /></td></tr>
<tr class="separator:ga746e8857cafe33ec5d6780729c18c311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec96b8e420d68b0e626df0812274d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga5ec96b8e420d68b0e626df0812274d46">arm_correlate_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst)</td></tr>
<tr class="memdesc:ga5ec96b8e420d68b0e626df0812274d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q15 sequences.  <a href="#ga5ec96b8e420d68b0e626df0812274d46">More...</a><br /></td></tr>
<tr class="separator:ga5ec96b8e420d68b0e626df0812274d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1367dc6c80476406c951e68d7fac4e8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga1367dc6c80476406c951e68d7fac4e8c">arm_correlate_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst)</td></tr>
<tr class="memdesc:ga1367dc6c80476406c951e68d7fac4e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q31 sequences.  <a href="#ga1367dc6c80476406c951e68d7fac4e8c">More...</a><br /></td></tr>
<tr class="separator:ga1367dc6c80476406c951e68d7fac4e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284ddcc49e4ac532d52a70d0383c5992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___corr.html#ga284ddcc49e4ac532d52a70d0383c5992">arm_correlate_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst)</td></tr>
<tr class="memdesc:ga284ddcc49e4ac532d52a70d0383c5992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlation of Q7 sequences.  <a href="#ga284ddcc49e4ac532d52a70d0383c5992">More...</a><br /></td></tr>
<tr class="separator:ga284ddcc49e4ac532d52a70d0383c5992"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Correlation is a mathematical operation that is similar to convolution. As with convolution, correlation uses two signals to produce a third signal. The underlying algorithms in correlation and convolution are identical except that one of the inputs is flipped in convolution. Correlation is commonly used to measure the similarity between two signals. It has applications in pattern recognition, cryptanalysis, and searching. The CMSIS library provides correlation functions for Q7, Q15, Q31 and floating-point data types. Fast versions of the Q15 and Q31 functions are also provided.</p>
<dl class="section user"><dt>Algorithm</dt><dd>Let <code>a[n]</code> and <code>b[n]</code> be sequences of length <code>srcALen</code> and <code>srcBLen</code> samples respectively. The convolution of the two signals is denoted by <pre>
                  c[n] = a[n] * b[n]
</pre> In correlation, one of the signals is flipped in time <pre>
                  c[n] = a[n] * b[-n]
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>and this is mathematically defined as <div class="image">
<img src="CorrelateEquation.gif" alt="CorrelateEquation.gif"/>
</div>
 </dd></dl>
<dl class="section user"><dt></dt><dd>The <code>pSrcA</code> points to the first input vector of length <code>srcALen</code> and <code>pSrcB</code> points to the second input vector of length <code>srcBLen</code>. The result <code>c[n]</code> is of length <code>2 * max(srcALen, srcBLen) - 1</code> and is defined over the interval <code>n=0, 1, 2, ..., (2 * max(srcALen, srcBLen) - 2)</code>. The output result is written to <code>pDst</code> and the calling function must allocate <code>2 * max(srcALen, srcBLen) - 1</code> words for the result.</dd></dl>
<p><b>Note</b> </p><dl class="section user"><dt></dt><dd>The <code>pDst</code> should be initialized to all zeros before being used.</dd></dl>
<p><b>Fixed-Point Behavior</b> </p><dl class="section user"><dt></dt><dd>Correlation requires summing up a large number of intermediate products. As such, the Q7, Q15, and Q31 functions run a risk of overflow and saturation. Refer to the function specific documentation below for further details of the particular algorithm used.</dd></dl>
<p><b>Fast Versions</b></p>
<dl class="section user"><dt></dt><dd>Fast versions are supported for Q31 and Q15. Cycles for Fast versions are less compared to Q31 and Q15 of correlate and the design requires the input signals should be scaled down to avoid intermediate overflows.</dd></dl>
<p><b>Opt Versions</b></p>
<dl class="section user"><dt></dt><dd>Opt versions are supported for Q15 and Q7. Design uses internal scratch buffer for getting good optimisation. These versions are optimised in cycles and consumes more memory(Scratch memory) compared to Q15 and Q7 versions of correlate </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga22021e4222773f01e9960358a531cfb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of floating-point sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulators</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counters</p>
<p>Destination address modifier</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we assume zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding has to be done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Zero is stored in the destination buffer</p>
<p>Decrement the loop counter</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>The function is internally divided into three parts according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first part of the algorithm, the multiplications increase by one for every iteration. In the second part of the algorithm, srcBLen number of multiplications are done. In the third part of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>The algorithm is implemented in three stages. The loop counters of each stage is initiated here.</p>
<p>sum = x[0] * y[srcBlen - 1] sum = x[0] * y[srcBlen-2] + x[1] * y[srcBlen - 1] .... sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 4]</p>
<p>x[1] * y[srcBLen - 3]</p>
<p>x[2] * y[srcBLen - 2]</p>
<p>x[3] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1] sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1] .... sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[0] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[0] * y[0]</p>
<p>acc1 += x[1] * y[0]</p>
<p>acc2 += x[2] * y[0]</p>
<p>acc3 += x[3] * y[0]</p>
<p>Read y[1] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[1] * y[1]</p>
<p>acc1 += x[2] * y[1]</p>
<p>acc2 += x[3] * y[1]</p>
<p>acc3 += x[4] * y[1]</p>
<p>Read y[2] sample</p>
<p>Read x[5] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[2]</p>
<p>acc1 += x[3] * y[2]</p>
<p>acc2 += x[4] * y[2]</p>
<p>acc3 += x[5] * y[2]</p>
<p>Read y[3] sample</p>
<p>Read x[6] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[3] * y[3]</p>
<p>acc1 += x[4] * y[3]</p>
<p>acc2 += x[5] * y[3]</p>
<p>acc3 += x[6] * y[3]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[4] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[4]</p>
<p>acc1 += x[5] * y[4]</p>
<p>acc2 += x[6] * y[4]</p>
<p>acc3 += x[7] * y[4]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 4</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over srcBLen</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] .... sum += x[srcALen-2] * y[0] + x[srcALen-1] * y[1] sum += x[srcALen-1] * y[0]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen - srcBLen + 4] * y[3]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[2]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[1]</p>
<p>sum += x[srcALen - srcBLen + 1] * y[0]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__correlate__f32_8c_source.html#l00116">116</a> of file <a class="el" href="arm__correlate__f32_8c_source.html">arm_correlate_f32.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga40a0236b17220e8e22a22b5bc1c53c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_fast_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, scratch buffers should be aligned by 32-bit</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>This fast version uses a 32-bit accumulator with 2.30 format. The accumulator maintains full precision of the intermediate multiplication results but provides only a single guard bit. There is no saturation on intermediate additions. Thus, if the accumulator overflows it wraps around and distorts the result. The input signals should be scaled down to avoid intermediate overflows. Scale down one of the inputs by 1/min(srcALen, srcBLen) to avoid overflow since a maximum of min(srcALen, srcBLen) number of additions is carried internally. The 2.30 accumulator is right shifted by 15 bits and then saturated to 1.15 format to yield the final result.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___corr.html#ga5ec96b8e420d68b0e626df0812274d46" title="Correlation of Q15 sequences. ">arm_correlate_q15()</a></code> for a slower implementation of this function which uses a 64-bit accumulator to avoid wrap around distortion. </dd></dl>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Accumulators</p>
<p>Intermediate inputB pointer</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counter</p>
<p>Destination address modifier</p>
<p>Intermediate pointers</p>
<p>output pointer</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>Update pointers</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Temporary pointer for scratch2</p>
<p>Actual correlation process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read four samples from scratch1 buffer</p>
<p>Read next four samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the results in the accumulators in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate correlation for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer </p>

<p>Definition at line <a class="el" href="arm__correlate__fast__opt__q15_8c_source.html#l00084">84</a> of file <a class="el" href="arm__correlate__fast__opt__q15_8c_source.html">arm_correlate_fast_opt_q15.c</a>.</p>

<p>References <a class="el" href="arm__copy__q15_8c_source.html#l00060">arm_copy_q15()</a>, and <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8de3da44f58e86c2c86156276ca154f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_fast_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>This fast version uses a 32-bit accumulator with 2.30 format. The accumulator maintains full precision of the intermediate multiplication results but provides only a single guard bit. There is no saturation on intermediate additions. Thus, if the accumulator overflows it wraps around and distorts the result. The input signals should be scaled down to avoid intermediate overflows. Scale down one of the inputs by 1/min(srcALen, srcBLen) to avoid overflow since a maximum of min(srcALen, srcBLen) number of additions is carried internally. The 2.30 accumulator is right shifted by 15 bits and then saturated to 1.15 format to yield the final result.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___corr.html#ga5ec96b8e420d68b0e626df0812274d46" title="Correlation of Q15 sequences. ">arm_correlate_q15()</a></code> for a slower implementation of this function which uses a 64-bit accumulator to avoid wrap around distortion. </dd></dl>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Accumulators</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counter</p>
<p>Destination address modifier</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>The function is internally divided into three parts according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first part of the algorithm, the multiplications increase by one for every iteration. In the second part of the algorithm, srcBLen number of multiplications are done. In the third part of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>The algorithm is implemented in three stages. The loop counters of each stage is initiated here.</p>
<p>sum = x[0] * y[srcBlen - 1] sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1] .... sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first loop starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 4] , x[1] * y[srcBLen - 3]</p>
<p>x[3] * y[srcBLen - 1] , x[2] * y[srcBLen - 2]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1] sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1] .... sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1] samples</p>
<p>read x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read the first two inputB samples using SIMD: y[0] and y[1]</p>
<p>acc0 += x[0] * y[0] + x[1] * y[1]</p>
<p>acc1 += x[1] * y[0] + x[2] * y[1]</p>
<p>Read x[2], x[3]</p>
<p>Read x[3], x[4]</p>
<p>acc2 += x[2] * y[0] + x[3] * y[1]</p>
<p>acc3 += x[3] * y[0] + x[4] * y[1]</p>
<p>Read y[2] and y[3]</p>
<p>acc0 += x[2] * y[2] + x[3] * y[3]</p>
<p>acc1 += x[3] * y[2] + x[4] * y[3]</p>
<p>Read x[4], x[5]</p>
<p>Read x[5], x[6]</p>
<p>acc2 += x[4] * y[2] + x[5] * y[3]</p>
<p>acc3 += x[5] * y[2] + x[6] * y[3]</p>
<p>For the next MAC operations, SIMD is not used So, the 16 bit pointer if inputB, py is updated</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[4]</p>
<p>Read x[7]</p>
<p>Perform the multiply-accumulates</p>
<p>Read y[4], y[5]</p>
<p>Read x[7], x[8]</p>
<p>Read x[9]</p>
<p>Perform the multiply-accumulates</p>
<p>Read y[4], y[5]</p>
<p>Read x[7], x[8]</p>
<p>Read x[9]</p>
<p>Perform the multiply-accumulates</p>
<p>Read y[6]</p>
<p>Read x[10]</p>
<p>Perform the multiply-accumulates</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over srcBLen</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] .... sum += x[srcALen-2] * y[0] + x[srcALen-1] * y[1] sum += x[srcALen-1] * y[0]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen - srcBLen + 4] * y[3] , sum += x[srcALen - srcBLen + 3] * y[2]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[1] , sum += x[srcALen - srcBLen + 1] * y[0]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__correlate__fast__q15_8c_source.html#l00077">77</a> of file <a class="el" href="arm__correlate__fast__q15_8c_source.html">arm_correlate_fast_q15.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabecd3d7b077dbbef43f93e9e037815ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_fast_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>This function is optimized for speed at the expense of fixed-point precision and overflow protection. The result of each 1.31 x 1.31 multiplication is truncated to 2.30 format. These intermediate results are accumulated in a 32-bit register in 2.30 format. Finally, the accumulator is saturated and converted to a 1.31 result.</dd></dl>
<dl class="section user"><dt></dt><dd>The fast version has the same overflow behavior as the standard version but provides less precision since it discards the low 32 bits of each multiplication result. In order to avoid overflows completely the input signals must be scaled down. The input signals should be scaled down to avoid intermediate overflows. Scale down one of the inputs by 1/min(srcALen, srcBLen)to avoid overflows since a maximum of min(srcALen, srcBLen) number of additions is carried internally.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___corr.html#ga1367dc6c80476406c951e68d7fac4e8c" title="Correlation of Q31 sequences. ">arm_correlate_q31()</a></code> for a slower implementation of this function which uses 64-bit accumulation to provide higher precision. </dd></dl>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulators</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counter</p>
<p>Destination address modifier</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>The function is internally divided into three parts according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first part of the algorithm, the multiplications increase by one for every iteration. In the second part of the algorithm, srcBLen number of multiplications are done. In the third part of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>The algorithm is implemented in three stages. The loop counters of each stage is initiated here.</p>
<p>sum = x[0] * y[srcBlen - 1] sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1] .... sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 4]</p>
<p>x[1] * y[srcBLen - 3]</p>
<p>x[2] * y[srcBLen - 2]</p>
<p>x[3] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1] sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1] .... sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[0] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[0] * y[0]</p>
<p>acc1 += x[1] * y[0]</p>
<p>acc2 += x[2] * y[0]</p>
<p>acc3 += x[3] * y[0]</p>
<p>Read y[1] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[1] * y[1]</p>
<p>acc1 += x[2] * y[1]</p>
<p>acc2 += x[3] * y[1]</p>
<p>acc3 += x[4] * y[1]</p>
<p>Read y[2] sample</p>
<p>Read x[5] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[2]</p>
<p>acc1 += x[3] * y[2]</p>
<p>acc2 += x[4] * y[2]</p>
<p>acc3 += x[5] * y[2]</p>
<p>Read y[3] sample</p>
<p>Read x[6] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[3] * y[3]</p>
<p>acc1 += x[4] * y[3]</p>
<p>acc2 += x[5] * y[3]</p>
<p>acc3 += x[6] * y[3]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[4] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[4]</p>
<p>acc1 += x[5] * y[4]</p>
<p>acc2 += x[6] * y[4]</p>
<p>acc3 += x[7] * y[4]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 4</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over srcBLen</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] .... sum += x[srcALen-2] * y[0] + x[srcALen-1] * y[1] sum += x[srcALen-1] * y[0]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen - srcBLen + 4] * y[3]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[2]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[1]</p>
<p>sum += x[srcALen - srcBLen + 1] * y[0]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__correlate__fast__q31_8c_source.html#l00081">81</a> of file <a class="el" href="arm__correlate__fast__q31_8c_source.html">arm_correlate_fast_q31.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad71c0ec70ec69edbc48563d9a5f68451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q15 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, scratch buffers should be aligned by 32-bit</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. Both inputs are in 1.15 format and multiplications yield a 2.30 result. The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format. This approach provides 33 guard bits and there is no risk of overflow. The 34.30 result is then truncated to 34.15 format by discarding the low 15 bits and then saturated to 1.15 format.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <code><a class="el" href="group___corr.html#gac8de3da44f58e86c2c86156276ca154f" title="Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_correlate_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4. </dd></dl>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Accumulators</p>
<p>Intermediate inputB pointer</p>
<p>temporary variables for holding input1 and input2 values</p>
<p>loop counter</p>
<p>output pointer increment</p>
<p>Intermediate pointers</p>
<p>output pointer</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>Update pointers</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Temporary pointer for scratch2</p>
<p>Actual correlation process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read four samples from scratch1 buffer</p>
<p>Read next four samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the results in the accumulators in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate correlation for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer </p>

<p>Definition at line <a class="el" href="arm__correlate__opt__q15_8c_source.html#l00083">83</a> of file <a class="el" href="arm__correlate__opt__q15_8c_source.html">arm_correlate_opt_q15.c</a>.</p>

<p>References <a class="el" href="arm__copy__q15_8c_source.html#l00060">arm_copy_q15()</a>, and <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="ga746e8857cafe33ec5d6780729c18c311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_opt_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q7 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<dl class="section user"><dt>Restrictions</dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 32-bit internal accumulator. Both the inputs are represented in 1.7 format and multiplications yield a 2.14 result. The 2.14 intermediate results are accumulated in a 32-bit accumulator in 18.14 format. This approach provides 17 guard bits and there is no risk of overflow as long as <code>max(srcALen, srcBLen)&lt;131072</code>. The 18.14 result is then truncated to 18.7 format by discarding the low 7 bits and saturated to 1.7 format. </dd></dl>
<p>output pointer</p>
<p>Temporary pointer for scratch</p>
<p>Temporary pointer for scratch</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Intermediate inputB pointer</p>
<p>Accumulators</p>
<p>loop counter</p>
<p>output pointer increment</p>
<p>loop counter</p>
<p>Temporary input variable</p>
<p>loop counter</p>
<p>Temporary input variables</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>Copy (srcBLen) samples in scratch buffer</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Fill (srcBLen - 1u) zeros in scratch buffer</p>
<p>Update temporary scratch pointer</p>
<p>Copy (srcALen) samples in scratch buffer</p>
<p>First part of the processing with loop unrolling copies 4 data points at a time. a second loop below copies for the remaining 1 to 3 samples.</p>
<p>copy second buffer in reversal manner</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, copy remaining samples here. No loop unrolling is used.</p>
<p>copy second buffer in reversal manner for remaining samples</p>
<p>Decrement the loop counter</p>
<p>Fill (srcBLen - 1u) zeros at end of scratch buffer</p>
<p>Update pointer</p>
<p>Temporary pointer for second sequence</p>
<p>Initialization of pScr2 pointer</p>
<p>Actual correlation process starts here</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Read two samples from scratch1 buffer</p>
<p>Read next two samples from scratch1 buffer</p>
<p>Read four samples from smaller buffer</p>
<p>multiply and accumlate</p>
<p>pack input data</p>
<p>multiply and accumlate</p>
<p>Read next two samples from scratch1 buffer</p>
<p>pack input data</p>
<p>Read four samples from smaller buffer</p>
<p>Decrement the loop counter</p>
<p>Update scratch pointer for remaining samples of smaller length sequence</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer</p>
<p>Calculate correlation for remaining samples of Bigger length sequence</p>
<p>Initialze temporary scratch pointer as scratch1</p>
<p>Clear Accumlators</p>
<p>Decrement the loop counter</p>
<p>apply same above for remaining samples of smaller length sequence</p>
<p>accumlate the results</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Initialization of inputB pointer </p>

<p>Definition at line <a class="el" href="arm__correlate__opt__q7_8c_source.html#l00083">83</a> of file <a class="el" href="arm__correlate__opt__q7_8c_source.html">arm_correlate_opt_q7.c</a>.</p>

<p>References <a class="el" href="arm__fill__q15_8c_source.html#l00061">arm_fill_q15()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ec96b8e420d68b0e626df0812274d46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q15 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. Both inputs are in 1.15 format and multiplications yield a 2.30 result. The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format. This approach provides 33 guard bits and there is no risk of overflow. The 34.30 result is then truncated to 34.15 format by discarding the low 15 bits and then saturated to 1.15 format.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <code><a class="el" href="group___corr.html#gac8de3da44f58e86c2c86156276ca154f" title="Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_correlate_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___corr.html#gad71c0ec70ec69edbc48563d9a5f68451" title="Correlation of Q15 sequences. ">arm_correlate_opt_q15()</a></code> for a faster implementation of this function using scratch buffers. </dd></dl>
<p>Run the below code for Cortex-M0</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>Accumulators</p>
<p>loop counters</p>
<p>Reverse order flag</p>
<p>Length</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and a varaible, inv is set to 1</p>
<p>If lengths are not equal then zero pad has to be done to make the two inputs of same length. But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Once the zero padding is done the remaining of the output is calcualted using convolution but with the shorter signal time shifted.</p>
<p>Calculate the length of the remaining sequence</p>
<p>Calculating the number of zeros to be padded to the output</p>
<p>Initialise the pointer after zero padding</p>
<p>Initialization to inputB pointer</p>
<p>Initialization to the end of inputA pointer</p>
<p>Initialisation of the pointer after zero padding</p>
<p>Swapping the lengths</p>
<p>Setting the reverse flag</p>
<p>Loop to calculate convolution for output length number of times</p>
<p>Initialize sum with zero to carry on MAC operations</p>
<p>Loop to perform MAC operations according to convolution equation</p>
<p>Check the array limitations</p>
<p>z[i] += x[i-j] * y[j]</p>
<p>Store the output in the destination buffer </p>

<p>Definition at line <a class="el" href="arm__correlate__q15_8c_source.html#l00079">79</a> of file <a class="el" href="arm__correlate__q15_8c_source.html">arm_correlate_q15.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1367dc6c80476406c951e68d7fac4e8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q31 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using an internal 64-bit accumulator. The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit. There is no saturation on intermediate additions. Thus, if the accumulator overflows it wraps around and distorts the result. The input signals should be scaled down to avoid intermediate overflows. Scale down one of the inputs by 1/min(srcALen, srcBLen)to avoid overflows since a maximum of min(srcALen, srcBLen) number of additions is carried internally. The 2.62 accumulator is right shifted by 31 bits and saturated to 1.31 format to yield the final result.</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___corr.html#gabecd3d7b077dbbef43f93e9e037815ed" title="Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4. ">arm_correlate_fast_q31()</a></code> for a faster but less precise implementation of this function for Cortex-M3 and Cortex-M4. </dd></dl>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulators</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counter</p>
<p>Destination address modifier</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>The function is internally divided into three parts according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first part of the algorithm, the multiplications increase by one for every iteration. In the second part of the algorithm, srcBLen number of multiplications are done. In the third part of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>The algorithm is implemented in three stages. The loop counters of each stage is initiated here.</p>
<p>sum = x[0] * y[srcBlen - 1] sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1] .... sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] * y[srcBLen - 4]</p>
<p>x[1] * y[srcBLen - 3]</p>
<p>x[2] * y[srcBLen - 2]</p>
<p>x[3] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1] sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1] .... sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll by 3</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1] samples</p>
<p>Apply loop unrolling and compute 3 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 3 MACs at a time. a second loop below computes MACs for the remaining 1 to 2 samples.</p>
<p>Read y[0] sample</p>
<p>Read x[2] sample</p>
<p>Perform the multiply-accumulate</p>
<p>acc0 += x[0] * y[0]</p>
<p>acc1 += x[1] * y[0]</p>
<p>acc2 += x[2] * y[0]</p>
<p>Read y[1] sample</p>
<p>Read x[3] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[1] * y[1]</p>
<p>acc1 += x[2] * y[1]</p>
<p>acc2 += x[3] * y[1]</p>
<p>Read y[2] sample</p>
<p>Read x[4] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[2] * y[2]</p>
<p>acc1 += x[3] * y[2]</p>
<p>acc2 += x[4] * y[2]</p>
<p>update scratch pointers</p>
<p>If the srcBLen is not a multiple of 3, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[4] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[4]</p>
<p>acc1 += x[5] * y[4]</p>
<p>acc2 += x[6] * y[4]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 3</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 3, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over srcBLen</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] .... sum += x[srcALen-2] * y[0] + x[srcALen-1] * y[1] sum += x[srcALen-1] * y[0]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Perform the multiply-accumulates</p>
<p>sum += x[srcALen - srcBLen + 4] * y[3]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[2]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[1]</p>
<p>sum += x[srcALen - srcBLen + 1] * y[0]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__correlate__q31_8c_source.html#l00078">78</a> of file <a class="el" href="arm__correlate__q31_8c_source.html">arm_correlate_q31.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga284ddcc49e4ac532d52a70d0383c5992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_correlate_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlation of Q7 sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length 2 * max(srcALen, srcBLen) - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 32-bit internal accumulator. Both the inputs are represented in 1.7 format and multiplications yield a 2.14 result. The 2.14 intermediate results are accumulated in a 32-bit accumulator in 18.14 format. This approach provides 17 guard bits and there is no risk of overflow as long as <code>max(srcALen, srcBLen)&lt;131072</code>. The 18.14 result is then truncated to 18.7 format by discarding the low 7 bits and saturated to 1.7 format.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___corr.html#ga746e8857cafe33ec5d6780729c18c311" title="Correlation of Q7 sequences. ">arm_correlate_opt_q7()</a></code> for a faster implementation of this function. </dd></dl>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>inputA pointer</p>
<p>inputB pointer</p>
<p>output pointer</p>
<p>Intermediate inputA pointer</p>
<p>Intermediate inputB pointer</p>
<p>Intermediate pointers</p>
<p>Accumulators</p>
<p>temporary variables</p>
<p>temporary variables</p>
<p>temporary variables for holding input and coefficient values</p>
<p>loop counter</p>
<p>The algorithm implementation is based on the lengths of the inputs.</p>
<p>srcB is always made to slide across srcA.</p>
<p>So srcBLen is always considered as shorter or equal to srcALen</p>
<p>But CORR(x, y) is reverse of CORR(y, x)</p>
<p>So, when srcBLen &gt; srcALen, output pointer is made to point to the end of the output buffer</p>
<p>and the destination pointer modifier, inc is set to -1</p>
<p>If srcALen &gt; srcBLen, zero pad has to be done to srcB to make the two inputs of same length</p>
<p>But to improve the performance, we include zeroes in the output instead of zero padding either of the the inputs</p>
<p>If srcALen &gt; srcBLen, (srcALen - srcBLen) zeroes has to included in the starting of the output buffer</p>
<p>If srcALen &lt; srcBLen, (srcALen - srcBLen) zeroes has to included in the ending of the output buffer</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>Number of output samples is calculated</p>
<p>When srcALen &gt; srcBLen, zero padding is done to srcB to make their lengths equal. Instead, (outBlockSize - (srcALen + srcBLen - 1)) number of output samples are made zero</p>
<p>Updating the pointer position to non zero value</p>
<p>Initialization of inputA pointer</p>
<p>Initialization of inputB pointer</p>
<p>srcBLen is always considered as shorter or equal to srcALen</p>
<p>CORR(x, y) = Reverse order(CORR(y, x))</p>
<p>Hence set the destination pointer to point to the last output sample</p>
<p>Destination address modifier is set to -1</p>
<p>The function is internally divided into three parts according to the number of multiplications that has to be taken place between inputA samples and inputB samples. In the first part of the algorithm, the multiplications increase by one for every iteration. In the second part of the algorithm, srcBLen number of multiplications are done. In the third part of the algorithm, the multiplications decrease by one for every iteration.</p>
<p>The algorithm is implemented in three stages. The loop counters of each stage is initiated here.</p>
<p>sum = x[0] * y[srcBlen - 1] sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1] .... sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]</p>
<p>In this stage the MAC operations are increased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>The first stage starts here</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[0] , x[1]</p>
<p>y[srcBLen - 4] , y[srcBLen - 3]</p>
<p>x[0] * y[srcBLen - 4]</p>
<p>x[1] * y[srcBLen - 3]</p>
<p>x[2] , x[3]</p>
<p>y[srcBLen - 2] , y[srcBLen - 1]</p>
<p>x[2] * y[srcBLen - 2]</p>
<p>x[3] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>x[0] * y[srcBLen - 1]</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Increment the MAC count</p>
<p>Decrement the loop counter</p>
<p>sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1] sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1] .... sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>count is index by which the pointer pIn1 to be incremented</p>
<p>Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed. So, to loop unroll over blockSize2, srcBLen should be greater than or equal to 4</p>
<p>Loop unroll over blockSize2, by 4</p>
<p>Set all accumulators to zero</p>
<p>read x[0], x[1], x[2] samples</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Read y[0] sample</p>
<p>Read y[1] sample</p>
<p>Read x[3] sample</p>
<p>x[0] and x[1] are packed</p>
<p>y[0] and y[1] are packed</p>
<p>acc0 += x[0] * y[0] + x[1] * y[1]</p>
<p>x[1] and x[2] are packed</p>
<p>acc1 += x[1] * y[0] + x[2] * y[1]</p>
<p>x[2] and x[3] are packed</p>
<p>acc2 += x[2] * y[0] + x[3] * y[1]</p>
<p>Read x[4] sample</p>
<p>x[3] and x[4] are packed</p>
<p>acc3 += x[3] * y[0] + x[4] * y[1]</p>
<p>Read y[2] sample</p>
<p>Read y[3] sample</p>
<p>Read x[5] sample</p>
<p>x[2] and x[3] are packed</p>
<p>y[2] and y[3] are packed</p>
<p>acc0 += x[2] * y[2] + x[3] * y[3]</p>
<p>x[3] and x[4] are packed</p>
<p>acc1 += x[3] * y[2] + x[4] * y[3]</p>
<p>x[4] and x[5] are packed</p>
<p>acc2 += x[4] * y[2] + x[5] * y[3]</p>
<p>Read x[6] sample</p>
<p>x[5] and x[6] are packed</p>
<p>acc3 += x[5] * y[2] + x[6] * y[3]</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Read y[4] sample</p>
<p>Read x[7] sample</p>
<p>Perform the multiply-accumulates</p>
<p>acc0 += x[4] * y[4]</p>
<p>acc1 += x[5] * y[4]</p>
<p>acc2 += x[6] * y[4]</p>
<p>acc3 += x[7] * y[4]</p>
<p>Reuse the present samples for the next MAC</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the blockSize2 is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>Reading two inputs of SrcA buffer and packing</p>
<p>Reading two inputs of SrcB buffer and packing</p>
<p>Perform the multiply-accumulates</p>
<p>Reading two inputs of SrcA buffer and packing</p>
<p>Reading two inputs of SrcB buffer and packing</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the pointer pIn1 index, count by 1</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>If the srcBLen is not a multiple of 4, the blockSize2 loop cannot be unrolled by 4</p>
<p>Accumulator is made zero for every iteration</p>
<p>Loop over srcBLen</p>
<p>Perform the multiply-accumulate</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Increment the MAC count</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the loop counter</p>
<p>sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1] .... sum += x[srcALen-2] * y[0] + x[srcALen-1] * y[1] sum += x[srcALen-1] * y[0]</p>
<p>In this stage the MAC operations are decreased by 1 for every iteration. The count variable holds the number of MAC operations performed</p>
<p>Working pointer of inputA</p>
<p>Working pointer of inputB</p>
<p>Accumulator is made zero for every iteration</p>
<p>Apply loop unrolling and compute 4 MACs simultaneously.</p>
<p>First part of the processing with loop unrolling. Compute 4 MACs at a time. a second loop below computes MACs for the remaining 1 to 3 samples.</p>
<p>x[srcALen - srcBLen + 1] , x[srcALen - srcBLen + 2]</p>
<p>y[0] , y[1]</p>
<p>sum += x[srcALen - srcBLen + 1] * y[0]</p>
<p>sum += x[srcALen - srcBLen + 2] * y[1]</p>
<p>x[srcALen - srcBLen + 3] , x[srcALen - srcBLen + 4]</p>
<p>y[2] , y[3]</p>
<p>sum += x[srcALen - srcBLen + 3] * y[2]</p>
<p>sum += x[srcALen - srcBLen + 4] * y[3]</p>
<p>Decrement the loop counter</p>
<p>If the count is not a multiple of 4, compute any remaining MACs here. No loop unrolling is used.</p>
<p>Perform the multiply-accumulates</p>
<p>Decrement the loop counter</p>
<p>Store the result in the accumulator in the destination buffer.</p>
<p>Destination pointer is updated according to the address modifier, inc</p>
<p>Update the inputA and inputB pointers for next MAC calculation</p>
<p>Decrement the MAC count</p>
<p>Decrement the loop counter </p>

<p>Definition at line <a class="el" href="arm__correlate__q7_8c_source.html#l00076">76</a> of file <a class="el" href="arm__correlate__q7_8c_source.html">arm_correlate_q7.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
