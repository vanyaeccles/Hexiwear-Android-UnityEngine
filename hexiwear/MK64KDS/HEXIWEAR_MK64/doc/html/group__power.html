<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HEXIWEAR MK64 Firmware Reference Manual: Power</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hexiweare_logo_main_black.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HEXIWEAR MK64 Firmware Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__power.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Power<div class="ingroups"><a class="el" href="group__group_stats.html">Statistics Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga993c00dd7f661d66bdb6e58426e893aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power.html#ga993c00dd7f661d66bdb6e58426e893aa">arm_power_f32</a> (float32_t *pSrc, uint32_t blockSize, float32_t *pResult)</td></tr>
<tr class="memdesc:ga993c00dd7f661d66bdb6e58426e893aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of the squares of the elements of a floating-point vector.  <a href="#ga993c00dd7f661d66bdb6e58426e893aa">More...</a><br /></td></tr>
<tr class="separator:ga993c00dd7f661d66bdb6e58426e893aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7050c04b7515e01a75c38f1abbaf71ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power.html#ga7050c04b7515e01a75c38f1abbaf71ba">arm_power_q15</a> (q15_t *pSrc, uint32_t blockSize, q63_t *pResult)</td></tr>
<tr class="memdesc:ga7050c04b7515e01a75c38f1abbaf71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of the squares of the elements of a Q15 vector.  <a href="#ga7050c04b7515e01a75c38f1abbaf71ba">More...</a><br /></td></tr>
<tr class="separator:ga7050c04b7515e01a75c38f1abbaf71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b93d31bb5b5ed214c2b94d8a7744cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power.html#ga0b93d31bb5b5ed214c2b94d8a7744cd2">arm_power_q31</a> (q31_t *pSrc, uint32_t blockSize, q63_t *pResult)</td></tr>
<tr class="memdesc:ga0b93d31bb5b5ed214c2b94d8a7744cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of the squares of the elements of a Q31 vector.  <a href="#ga0b93d31bb5b5ed214c2b94d8a7744cd2">More...</a><br /></td></tr>
<tr class="separator:ga0b93d31bb5b5ed214c2b94d8a7744cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf969c85c5655e3d72d7b99ff188f92c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__power.html#gaf969c85c5655e3d72d7b99ff188f92c9">arm_power_q7</a> (q7_t *pSrc, uint32_t blockSize, q31_t *pResult)</td></tr>
<tr class="memdesc:gaf969c85c5655e3d72d7b99ff188f92c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of the squares of the elements of a Q7 vector.  <a href="#gaf969c85c5655e3d72d7b99ff188f92c9">More...</a><br /></td></tr>
<tr class="separator:gaf969c85c5655e3d72d7b99ff188f92c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Calculates the sum of the squares of the elements in the input vector. The underlying algorithm is used:</p>
<pre>
    Result = pSrc[0] * pSrc[0] + pSrc[1] * pSrc[1] + pSrc[2] * pSrc[2] + ... + pSrc[blockSize-1] * pSrc[blockSize-1];
</pre><p>There are separate functions for floating point, Q31, Q15, and Q7 data types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga993c00dd7f661d66bdb6e58426e893aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_power_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of the squares of the elements of a floating-point vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>sum of the squares value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<p>accumulator</p>
<p>Temporary variable to store input value</p>
<p>loop counter</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>compute power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>Store the result to the destination </p>

<p>Definition at line <a class="el" href="arm__power__f32_8c_source.html#l00076">76</a> of file <a class="el" href="arm__power__f32_8c_source.html">arm_power_f32.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7050c04b7515e01a75c38f1abbaf71ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_power_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q63_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of the squares of the elements of a Q15 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>sum of the squares value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. The input is represented in 1.15 format. Intermediate multiplication yields a 2.30 format, and this result is added without saturation to a 64-bit accumulator in 34.30 format. With 33 guard bits in the accumulator, there is no risk of overflow, and the full precision of the intermediate multiplication is preserved. Finally, the return result is in 34.30 format. </dd></dl>
<p>Temporary result storage</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Temporary variable to store input value</p>
<p>Temporary variable to store input value</p>
<p>loop counter</p>
<p>loop Unrolling</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>Store the results in 34.30 format </p>

<p>Definition at line <a class="el" href="arm__power__q15_8c_source.html#l00073">73</a> of file <a class="el" href="arm__power__q15_8c_source.html">arm_power_q15.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b93d31bb5b5ed214c2b94d8a7744cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_power_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q63_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of the squares of the elements of a Q31 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>sum of the squares value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. The input is represented in 1.31 format. Intermediate multiplication yields a 2.62 format, and this result is truncated to 2.48 format by discarding the lower 14 bits. The 2.48 result is then added without saturation to a 64-bit accumulator in 16.48 format. With 15 guard bits in the accumulator, there is no risk of overflow, and the full precision of the intermediate multiplication is preserved. Finally, the return result is in 16.48 format. </dd></dl>
<p>Temporary result storage</p>
<p>loop counter</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power then shift intermediate results by 14 bits to maintain 16.48 format and then store the result in a temporary variable sum, providing 15 guard bits.</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>Store the results in 16.48 format </p>

<p>Definition at line <a class="el" href="arm__power__q31_8c_source.html#l00074">74</a> of file <a class="el" href="arm__power__q31_8c_source.html">arm_power_q31.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf969c85c5655e3d72d7b99ff188f92c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_power_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of the squares of the elements of a Q7 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrc</td><td>points to the input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blockSize</td><td>length of the input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pResult</td><td>sum of the squares value returned here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<p><b>Scaling and Overflow Behavior:</b></p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 32-bit internal accumulator. The input is represented in 1.7 format. Intermediate multiplication yields a 2.14 format, and this result is added without saturation to an accumulator in 18.14 format. With 17 guard bits in the accumulator, there is no risk of overflow, and the full precision of the intermediate multiplication is preserved. Finally, the return result is in 18.14 format. </dd></dl>
<p>Temporary result storage</p>
<p>Temporary variable to store input</p>
<p>loop counter</p>
<p>Run the below code for Cortex-M4 and Cortex-M3</p>
<p>Temporary variable to store packed input</p>
<p>Temporary variables to store input</p>
<p>First part of the processing with loop unrolling. Compute 4 outputs at a time. a second loop below computes the remaining 1 to 3 samples.</p>
<p>Reading two inputs of pSrc vector and packing</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>calculate power and accumulate to accumulator</p>
<p>Decrement the loop counter</p>
<p>If the blockSize is not a multiple of 4, compute any remaining output samples here. No loop unrolling is used.</p>
<p>C = A[0] * A[0] + A[1] * A[1] + A[2] * A[2] + ... + A[blockSize-1] * A[blockSize-1]</p>
<p>Compute Power and then store the result in a temporary variable, sum.</p>
<p>Decrement the loop counter</p>
<p>Store the result in 18.14 format </p>

<p>Definition at line <a class="el" href="arm__power__q7_8c_source.html#l00073">73</a> of file <a class="el" href="arm__power__q7_8c_source.html">arm_power_q7.c</a>.</p>

<p>References <a class="el" href="cmsis__armcc_8h_source.html#l00417">__ROR</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
